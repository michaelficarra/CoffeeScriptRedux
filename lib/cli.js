// Generated by CoffeeScript 2.0.0-beta9-dev
var $0, additionalArgs, cache$, cache$1, cache$2, CoffeeScript, concat, cscodegen, escodegen, esmangle, foldl, fs, humanReadable, input, inputName, inputSource, inspect, knownOpts, nopt, numberLines, optAliases, Optimiser, option, options, output, parameter, path, pkg, positionalArgs, Preprocessor, processInput, Repl, runMain;
fs = require('fs');
path = require('path');
cache$ = require('./functional-helpers');
concat = cache$.concat;
foldl = cache$.foldl;
cache$1 = require('./helpers');
numberLines = cache$1.numberLines;
humanReadable = cache$1.humanReadable;
Preprocessor = require('./preprocessor').Preprocessor;
Optimiser = require('./optimiser').Optimiser;
runMain = require('./run').runMain;
CoffeeScript = require('./module');
Repl = require('./repl');
nopt = require('nopt');
cscodegen = function () {
  try {
    return require('cscodegen');
  } catch (e$) {
    return;
  }
}.call(this);
escodegen = function () {
  try {
    return require('escodegen');
  } catch (e$1) {
    return;
  }
}.call(this);
esmangle = function () {
  try {
    return require('esmangle');
  } catch (e$2) {
    return;
  }
}.call(this);
inspect = function (o) {
  return require('util').inspect(o, false, 9e9, true);
};
knownOpts = {};
option = function () {
  var o;
  for (var i$ = 0, length$ = arguments.length; i$ < length$; ++i$) {
    o = arguments[i$];
    knownOpts[o] = Boolean;
  }
};
parameter = function () {
  var p;
  for (var i$ = 0, length$ = arguments.length; i$ < length$; ++i$) {
    p = arguments[i$];
    knownOpts[p] = String;
  }
};
optAliases = {
  b: '--bare',
  c: '--compile',
  e: '--eval',
  f: '--cscodegen',
  I: '--require',
  i: '--input',
  j: '--js',
  l: '--literate',
  m: '--minify',
  o: '--output',
  p: '--parse',
  v: '--version',
  w: '--watch'
};
option('parse', 'compile', 'optimise', 'debug', 'literate', 'raw', 'version', 'help', 'target-es6');
parameter('cli', 'input', 'nodejs', 'output', 'watch');
if (null != escodegen) {
  option('bare', 'js', 'source-map', 'eval', 'repl');
  parameter('source-map-file', 'require');
  if (null != esmangle) {
    option('minify');
  }
}
if (null != cscodegen) {
  option('cscodegen');
}
options = nopt(knownOpts, optAliases, process.argv, 2);
positionalArgs = options.argv.remain;
delete options.argv;
if (null != options.optimise)
  options.optimise;
else
  options.optimise = true;
options.sourceMap = options['source-map'];
options.sourceMapFile = options['source-map-file'];
options.targetES6 = options['target-es6'];
if (!(options.compile || options.js || options.sourceMap || options.parse || options['eval'] || options.cscodegen)) {
  if (!(null != escodegen)) {
    options.compile = true;
  } else if (positionalArgs.length) {
    options['eval'] = true;
    options.input = positionalArgs.shift();
    additionalArgs = positionalArgs;
  } else {
    options.repl = true;
  }
}
if (1 !== (null != options.parse ? options.parse : 0) + (null != options.compile ? options.compile : 0) + (null != options.js ? options.js : 0) + (null != options.sourceMap ? options.sourceMap : 0) + (null != options['eval'] ? options['eval'] : 0) + (null != options.cscodegen ? options.cscodegen : 0) + (null != options.repl ? options.repl : 0)) {
  console.error('Error: At most one of --parse (-p), --compile (-c), --js (-j), --source-map, --eval (-e), --cscodegen, or --repl may be used.');
  process.exit(1);
}
if (1 < (null != options.input) + (null != options.watch) + (null != options.cli)) {
  console.error('Error: At most one of --input (-i), --watch (-w), or --cli may be used.');
  process.exit(1);
}
if (null != options.require && !options['eval']) {
  console.error('Error: --require (-I) depends on --eval (-e)');
  process.exit(1);
}
if (options.minify && !(options.js || options['eval'])) {
  console.error('Error: --minify does not make sense without --js or --eval');
  process.exit(1);
}
if (options.bare && !(options.compile || options.js || options.sourceMap || options['eval'])) {
  console.error('Error: --bare does not make sense without --compile, --js, --source-map, or --eval');
  process.exit(1);
}
if (options.sourceMapFile && !options.js) {
  console.error('Error: --source-map-file depends on --js');
  process.exit(1);
}
if (null != options.input && fs.statSync(options.input).isDirectory() && (!(null != options.output) || (null != (cache$2 = fs.statSync(options.output)) ? cache$2.isFile() : void 0))) {
  console.error('Error: when --input is a directory, --output must be provided, and --output must not reference a file');
  process.exit(1);
}
if (options.cscodegen && !(null != cscodegen)) {
  console.error('Error: cscodegen must be installed to use --cscodegen');
  process.exit(1);
}
output = function (out) {
  if (options.output) {
    return fs.writeFile(options.output, '' + out + '\n', function (err) {
      if (null != err) {
        throw err;
      }
    });
  } else {
    return process.stdout.write('' + out + '\n');
  }
};
if (options.help) {
  $0 = process.argv[0] === 'node' ? process.argv[1] : process.argv[0];
  $0 = path.basename($0);
  console.log('\n  Usage: (OPT is interpreted by ' + $0 + ', ARG is passed to FILE)\n\n    ' + $0 + ' OPT* -{p,c,j,f} OPT*\n      example: ' + $0 + ' --js --no-optimise <input.coffee >output.js\n    ' + $0 + ' [-e] FILE {OPT,ARG}* [-- ARG*]\n      example: ' + $0 + ' myfile.coffee arg0 arg1\n    ' + $0 + ' OPT* [--repl] OPT*\n      example: ' + $0 + '\n\n  -b, --bare              omit the top-level function wrapper\n  -c, --compile           output a JSON-serialised AST representation of the output\n  -e, --eval              evaluate compiled JavaScript\n  -f, --cscodegen         output cscodegen-generated CoffeeScript code\n  -i, --input FILE        file to be used as input instead of STDIN\n  -I, --require FILE      require a library before a script is executed\n  -j, --js                generate JavaScript output\n  -l, --literate          treat the input as literate CoffeeScript code\n  -m, --minify            run compiled javascript output through a JS minifier\n  -o, --output FILE       file to be used as output instead of STDOUT\n  -p, --parse             output a JSON-serialised AST representation of the input\n  -v, --version           display the version number\n  -w, --watch FILE        watch the given file/directory for changes\n  --cli INPUT             pass a string from the command line as input\n  --debug                 output intermediate representations on stderr for debug\n  --help                  display this help message\n  --nodejs OPTS           pass options through to the node binary\n  --optimise              enable optimisations (default: on)\n  --raw                   preserve source position and raw parse information\n  --repl                  run an interactive CoffeeScript REPL\n  --source-map            generate source map\n  --source-map-file FILE  file used as output for source map when using --js\n\n  Unless given --input or --cli flags, `' + $0 + '` will operate on stdin/stdout.\n  When none of --{parse,compile,js,source-map,eval,cscodegen,repl} are given,\n    If positional arguments were given\n      * --eval is implied\n      * the first positional argument is used as an input filename\n      * additional positional arguments are passed as arguments to the script\n    Else --repl is implied\n');
} else if (options.version) {
  pkg = require('./../package.json');
  console.log('CoffeeScript version ' + pkg.version);
} else if (options.repl) {
  CoffeeScript.register();
  process.argv.shift();
  Repl.start();
} else {
  input = '';
  inputName = null != options.input ? options.input : options.cli && 'cli' || 'stdin';
  inputSource = null != options.input ? fs.realpathSync(options.input) : options.cli && '(cli)' || '(stdin)';
  processInput = function (err) {
    var cache$3, e, js, jsAST, preprocessed, result, sourceMap, sourceMappingUrl;
    if (null != err) {
      throw err;
    }
    result = null;
    input = input.toString();
    if (65279 === input.charCodeAt(0)) {
      input = input.slice(1);
    }
    if (options.debug) {
      try {
        console.error('### PREPROCESSED CS ###');
        preprocessed = Preprocessor.process(input, { literate: options.literate });
        console.error(numberLines(humanReadable(preprocessed)));
      } catch (e$3) {
      }
    }
    try {
      result = CoffeeScript.parse(input, {
        optimise: false,
        raw: options.raw || options.sourceMap || options.sourceMapFile || options['eval'],
        inputSource: inputSource,
        literate: options.literate
      });
    } catch (e$4) {
      e = e$4;
      console.error(e.message);
      process.exit(1);
    }
    if (options.debug && options.optimise && null != result) {
      console.error('### PARSED CS-AST ###');
      console.error(inspect(result.toBasicObject()));
    }
    if (options.optimise && null != result) {
      result = Optimiser.optimise(result);
    }
    if (options.parse) {
      if (null != result) {
        output(inspect(result.toBasicObject()));
        return;
      } else {
        process.exit(1);
      }
    }
    if (options.debug && null != result) {
      console.error('### ' + (options.optimise ? 'OPTIMISED' : 'PARSED') + ' CS-AST ###');
      console.error(inspect(result.toBasicObject()));
    }
    if (options.cscodegen) {
      try {
        result = cscodegen.generate(result);
      } catch (e$5) {
        e = e$5;
        console.error(e.stack || e.message);
        process.exit(1);
      }
      if (null != result) {
        output(result);
        return;
      } else {
        process.exit(1);
      }
    }
    jsAST = CoffeeScript.compile(result, {
      bare: options.bare,
      targetES6: options.targetES6
    });
    if (options.compile) {
      if (null != jsAST) {
        output(inspect(jsAST));
        return;
      } else {
        process.exit(1);
      }
    }
    if (options.debug && null != jsAST) {
      console.error('### COMPILED JS-AST ###');
      console.error(inspect(jsAST));
    }
    if (options.minify) {
      try {
        jsAST = esmangle.mangle(esmangle.optimize(jsAST), { destructive: true });
      } catch (e$6) {
        e = e$6;
        console.error(e.stack || e.message);
        process.exit(1);
      }
    }
    if (options.sourceMap) {
      try {
        sourceMap = CoffeeScript.sourceMap(jsAST, inputName, { compact: options.minify });
      } catch (e$7) {
        e = e$7;
        console.error(e.stack || e.message);
        process.exit(1);
      }
      if (null != sourceMap) {
        output('' + sourceMap);
        return;
      } else {
        process.exit(1);
      }
    }
    try {
      cache$3 = CoffeeScript.jsWithSourceMap(jsAST, inputName, { compact: options.minify });
      js = cache$3.code;
      sourceMap = cache$3.map;
      cache$3;
    } catch (e$8) {
      e = e$8;
      console.error(e.stack || e.message);
      process.exit(1);
    }
    if (options.js) {
      if (options.sourceMapFile) {
        fs.writeFileSync(options.sourceMapFile, '' + sourceMap);
        sourceMappingUrl = options.output ? path.relative(path.dirname(options.output), options.sourceMapFile) : options.sourceMapFile;
        js = '' + js + '\n\n//# sourceMappingURL=' + sourceMappingUrl + '';
      }
      output(js);
      return;
    }
    if (options['eval']) {
      CoffeeScript.register();
      process.argv = [
        process.argv[1],
        options.input
      ].concat(additionalArgs);
      runMain(input, js, jsAST, inputSource);
      return;
    }
  };
  if (null != options.input) {
    fs.stat(options.input, function (err, stats) {
      if (null != err) {
        throw err;
      }
      if (stats.isDirectory()) {
        options.input = path.join(options.input, 'index.coffee');
      }
      return fs.readFile(options.input, function (err, contents) {
        if (null != err) {
          throw err;
        }
        input = contents;
        return processInput();
      });
    });
  } else if (null != options.watch) {
    options.watch;
  } else if (null != options.cli) {
    input = options.cli;
    processInput();
  } else {
    process.stdin.on('data', function (data) {
      return input += data;
    });
    process.stdin.on('end', processInput);
    process.stdin.setEncoding('utf8');
    process.stdin.resume();
  }
}

// Generated by CoffeeScript 2.0.0-beta1
var cscodegen, escodegen, esmangle, foldl, optionArguments, options, parameterArguments, path, requires, writeHelp, writeVersion;
cscodegen = function () {
  try {
    return require('cscodegen');
  } catch (e$) {
    return;
  }
}.call(this);
escodegen = function () {
  try {
    return require('escodegen');
  } catch (e$) {
    return;
  }
}.call(this);
esmangle = function () {
  try {
    return require('esmangle');
  } catch (e$) {
    return;
  }
}.call(this);
foldl = require('./functional-helpers').foldl;
path = require('path');
requires = function (mods) {
  mods = 1 <= arguments.length ? [].slice.call(arguments, 0) : [];
  return {
    pass: mods.every(function (mod) {
      return eval(mod) !== null;
    }),
    toString: function () {
      return 'Requires ' + mods.map(function (mod) {
        return '' + mod + ' [' + (eval(mod) === null ? 'not-ok' : 'ok') + ']';
      }).join('and');
    }
  };
};
optionArguments = [
  [
    ['optimise'],
    true,
    'enable optimisations (default: on)'
  ],
  [
    ['debug'],
    false,
    'output intermediate representations on stderr for debug'
  ],
  [
    ['raw'],
    false,
    'preserve source position and raw parse information'
  ],
  [
    [
      'version',
      'v'
    ],
    false,
    'display the version number'
  ],
  [
    ['help'],
    false,
    'display this help message'
  ],
  [
    [
      'bare',
      'b'
    ],
    false,
    'omit the top-level function wrapper',
    requires('escodegen')
  ],
  [
    [
      'eval',
      'e'
    ],
    false,
    'evaluate compiled JavaScript',
    requires('escodegen')
  ],
  [
    ['repl'],
    false,
    'run an interactive CoffeeScript REPL',
    requires('escodegen')
  ],
  [
    ['include-source-reference'],
    true,
    'append sourceURL or sourceMappingURL in js output',
    requires('escodegen')
  ],
  [
    [
      'minify',
      'm'
    ],
    false,
    'run compiled javascript output through a JS minifier',
    requires('escodegen', 'esmangle')
  ]
];
parameterArguments = [
  [
    [
      'parse',
      'p'
    ],
    'FILE',
    'output a JSON-serialised AST representation of the input'
  ],
  [
    [
      'compile',
      'c'
    ],
    'FILE',
    'output a JSON-serialised AST representation of the output'
  ],
  [
    ['cli'],
    'INPUT',
    'pass a string from the command line as input'
  ],
  [
    [
      'input',
      'i'
    ],
    'FILE',
    'file to be used as input instead of STDIN'
  ],
  [
    ['nodejs'],
    'OPTS',
    'pass options through to the node binary'
  ],
  [
    [
      'output',
      'o'
    ],
    'FILE',
    'file to be used as output instead of STDIN'
  ],
  [
    [
      'watch',
      'w'
    ],
    'FILE',
    'watch the given file/directory for changes'
  ],
  [
    [
      'js',
      'j'
    ],
    'FILE',
    'generate JavaScript output',
    requires('escodegen')
  ],
  [
    ['source-map'],
    'FILE',
    'generate source map',
    requires('escodegen')
  ],
  [
    [
      'require',
      'I'
    ],
    'FILE',
    'require a library before a script is executed',
    requires('escodegen', 'esmangle')
  ],
  [
    [
      'cscodegen',
      'f'
    ],
    false,
    'output cscodegen-generated CoffeeScript code',
    requires('cscodegen')
  ]
];
writeVersion = function () {
  var pkg;
  pkg = require('./../../package.json');
  return console.log('CoffeeScript version ' + pkg.version);
};
writeHelp = function (_args) {
  var $0, formatOptions, leftColumnWidth, maxWidth, optionRows, parameterRows, row, rows, wrap;
  $0 = _args[0] === 'node' ? _args[1] : _args[0];
  $0 = path.basename($0);
  maxWidth = 85;
  wrap = function (lhsWidth, input) {
    var pad, rhsWidth, rows;
    rhsWidth = maxWidth - lhsWidth;
    pad = Array(lhsWidth + 4 + 1).join(' ');
    rows = function (accum$) {
      var row;
      while (input.length) {
        row = input.slice(0, rhsWidth);
        input = input.slice(rhsWidth);
        accum$.push(row);
      }
      return accum$;
    }.call(this, []);
    return rows.join('\n' + pad);
  };
  formatOptions = function (opts) {
    opts = function (accum$) {
      var opt;
      for (var i$ = 0, length$ = opts.length; i$ < length$; ++i$) {
        opt = opts[i$];
        if (!opt.length)
          continue;
        accum$.push(opt.length === 1 ? '-' + opt : '--' + opt);
      }
      return accum$;
    }.call(this, []);
    opts.sort(function (a, b) {
      return a.length - b.length;
    });
    return opts.join(', ');
  };
  console.log('\n    Usage:\n      ' + $0 + ' FILE ARG* [-- ARG*]\n      ' + $0 + ' OPT* [--repl] OPT*\n      ' + $0 + ' OPT* -{-parse,p,-compile,c,-js,j,-cscodegen} OPT*\n      ' + $0 + ' {OPT,ARG}* -{-eval,e} {OPT,ARG}* -- ARG*\n\n  ');
  optionRows = function (accum$) {
    var opt;
    for (var i$ = 0, length$ = optionArguments.length; i$ < length$; ++i$) {
      opt = optionArguments[i$];
      accum$.push([
        formatOptions(opt[0]),
        opt[2]
      ]);
    }
    return accum$;
  }.call(this, []);
  parameterRows = function (accum$) {
    var opt;
    for (var i$ = 0, length$ = parameterArguments.length; i$ < length$; ++i$) {
      opt = parameterArguments[i$];
      accum$.push([
        '' + formatOptions(opt[0]) + ' ' + opt[1],
        opt[2]
      ]);
    }
    return accum$;
  }.call(this, []);
  leftColumnWidth = foldl(0, [].slice.call(optionRows).concat([].slice.call(parameterRows)), function (memo, opt) {
    return Math.max(memo, opt[0].length);
  });
  rows = [].slice.call(optionRows).concat([].slice.call(parameterRows));
  rows.sort(function (a, b) {
    a = a[0];
    b = b[0];
    if (a.slice(0, +1 + 1 || 9e9) === '--' && b.slice(0, +1 + 1 || 9e9) !== '--')
      return 1;
    if (b.slice(0, +1 + 1 || 9e9) === '--' && a.slice(0, +1 + 1 || 9e9) !== '--')
      return -1;
    if (a.toLowerCase() < b.toLowerCase()) {
      return -1;
    } else {
      return 1;
    }
  });
  for (var i$ = 0, length$ = rows.length; i$ < length$; ++i$) {
    row = rows[i$];
    console.log('  ' + row[0] + Array(leftColumnWidth - row[0].length + 1).join(' ') + '  ' + wrap(leftColumnWidth, row[1]));
  }
  return console.log('\n\n    Unless instructed otherwise (--{input,watch,cli}), `' + $0 + '` will operate on stdin/stdout.\n    When none of -{-parse,p,-compile,c,-js,j,-eval,e,-cscodegen,-repl} are given\n      If positional arguments were given\n        * --eval is implied\n        * the first positional argument is used as an input filename\n        * additional positional arguments are passed as arguments to the script\n      Else --repl is implied\n  ');
};
options = {};
exports.process = function (_args) {
  var arg, args, cache$1, cache$2, cache$3, cache$4, cache$5, longOptionArguments, longParameterArguments, match, o, optionMap, opts, outputType, outputTypeDirectedToStdOut, parameterIsPresent, positionalArgs, reLongOption, reLongParameter, reShortOptions, reShortOptionsShortParameter, reShortParameter, shortOptionArguments, shortParameterArguments;
  args = _args.slice(1 + (process.argv[0] === 'node'));
  options.additionalArgs = [];
  if (in$('--', args))
    options.additionalArgs = args.splice(args.indexOf('--'), 9e9).slice(1);
  optionMap = {};
  shortOptionArguments = [];
  longOptionArguments = [];
  for (var i$ = 0, length$ = optionArguments.length; i$ < length$; ++i$) {
    opts = optionArguments[i$];
    options[opts[0][0]] = opts[1];
    for (var i$1 = 0, length$1 = opts[0].length; i$1 < length$1; ++i$1) {
      o = opts[0][i$1];
      optionMap[o] = opts[0][0];
      if (o.length === 1) {
        shortOptionArguments.push(o);
      } else if (o.length > 1) {
        longOptionArguments.push(o);
      }
    }
  }
  shortParameterArguments = [];
  longParameterArguments = [];
  for (var i$2 = 0, length$2 = parameterArguments.length; i$2 < length$2; ++i$2) {
    opts = parameterArguments[i$2];
    for (var i$3 = 0, length$3 = opts[0].length; i$3 < length$3; ++i$3) {
      o = opts[0][i$3];
      optionMap[o] = opts[0][0];
      if (o.length === 1) {
        shortParameterArguments.push(o);
      } else if (o.length > 1) {
        longParameterArguments.push(o);
      }
    }
  }
  reShortOptions = new RegExp('^-(' + shortOptionArguments.join('|') + ')+$');
  reLongOption = new RegExp('^--(no-)?(' + longOptionArguments.join('|') + ')$');
  reShortParameter = new RegExp('^-(' + shortParameterArguments.join('|') + ')$');
  reLongParameter = new RegExp('^--(' + longParameterArguments.join('|') + ')$');
  reShortOptionsShortParameter = new RegExp('^-(' + shortOptionArguments.join('|') + ')+(' + shortParameterArguments.join('|') + ')$');
  positionalArgs = [];
  while (args.length) {
    arg = args.shift();
    if (reShortOptionsShortParameter.exec(arg)) {
      args.unshift('-' + arg.slice(1, -1), '-' + arg.slice(-1));
    } else if (reShortOptions.exec(arg)) {
      for (var cache$ = arg.slice(1).split(''), i$4 = 0, length$4 = cache$.length; i$4 < length$4; ++i$4) {
        o = cache$[i$4];
        options[optionMap[o]] = true;
      }
    } else if (match = reLongOption.exec(arg)) {
      options[optionMap[match[2]]] = null != match[1] ? false : true;
    } else if (match = (cache$1 = reShortParameter.exec(arg), null != cache$1 ? cache$1 : reLongParameter.exec(arg))) {
      parameterIsPresent = null != args[0] && !(cache$2 = reShortOptions.exec(args[0]), null != cache$2 ? cache$2 : (cache$3 = reLongOption.exec(args[0]), null != cache$3 ? cache$3 : (cache$4 = reShortParameter.exec(args[0]), null != cache$4 ? cache$4 : (cache$5 = reLongParameter.exec(args[0]), null != cache$5 ? cache$5 : reShortOptionsShortParameter.exec(args[0])))));
      if (parameterIsPresent) {
        options[optionMap[match[1]]] = args.shift();
      } else {
        options[optionMap[match[1]]] = '';
      }
    } else if (match = /^(-.|--.*)$/.exec(arg)) {
      console.error("Unrecognised option '" + match[0].replace(/'/g, "\\'") + "'");
      process.exit(1);
    } else {
      positionalArgs.push(arg);
    }
  }
  if (options.help) {
    writeHelp(_args);
    process.exit(0);
  }
  if (options.version) {
    writeVersion();
    process.exit(0);
  }
  outputTypeDirectedToStdOut = false;
  for (var cache$6 = [
        'parse',
        'compile',
        'js',
        'source-map',
        'cscodegen'
      ], i$5 = 0, length$5 = cache$6.length; i$5 < length$5; ++i$5) {
    outputType = cache$6[i$5];
    if (in$(options[outputType], [
        'FILE',
        '',
        '-',
        '(stdout)',
        'STDOUT'
      ])) {
      if (outputTypeDirectedToStdOut)
        throw Error('Multiple output types cannot write to STDOUT. Provide either --' + outputTypeDirectedToStdOut + ' or --' + outputType + ' with an output file path.');
      options[outputType] = '(stdout)';
      outputTypeDirectedToStdOut = outputType;
    }
  }
  if (options['eval'] && outputTypeDirectedToStdOut)
    throw Error('--eval must have full use of STDOUT. Provide --' + outputTypeDirectedToStdOut + ' with an output file path.');
  return options;
};
function in$(member, list) {
  for (var i = 0, length = list.length; i < length; ++i)
    if (i in list && list[i] === member)
      return true;
  return false;
}
//@ sourceURL=src/cli-options.coffee

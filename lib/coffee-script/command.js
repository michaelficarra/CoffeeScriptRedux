// Generated by CoffeeScript 2.0.0-dev
var $0, $0, additionalArgs, additionalArgs, additionalArgs, arg, args, CoffeeScript, concat, cscodegen, escodegen, foldl, formatOptions, fs, humanReadable, input, input, inspect, leftColumnWidth, longOptionArguments, longParameterArguments, match, match, match, maxWidth, numberLines, o, o, o, Optimiser, optionArguments, optionMap, optionRows, options, opts, opts, parameterArguments, parameterRows, path, pkg, positionalArgs, positionalArgs, Preprocessor, processInput, reLongOption, reLongParameter, reShortOptions, reShortOptionsShortParameter, reShortParameter, row, rows, shortOptionArguments, shortParameterArguments, uglifyjs, wrap;
fs = require('fs');
path = require('path');
cache$ = require('./functional-helpers');
concat = cache$.concat;
foldl = cache$.foldl;
cache$1 = require('./helpers');
numberLines = cache$1.numberLines;
humanReadable = cache$1.humanReadable;
Preprocessor = require('./preprocessor').Preprocessor;
Optimiser = require('./optimiser').Optimiser;
CoffeeScript = require('./module');
cscodegen = function () {
  try {
    return require('cscodegen');
  } catch (e$) {
    return;
  }
}.call(this);
escodegen = function () {
  try {
    return require('escodegen');
  } catch (e$) {
    return;
  }
}.call(this);
uglifyjs = function () {
  try {
    return require('uglify-js');
  } catch (e$) {
    return;
  }
}.call(this);
inspect = function (o) {
  return require('util').inspect(o, false, 9e9, true);
};
args = process.argv.slice(1 + (process.argv[0] === 'node'));
additionalArgs = [];
if (in$('--', args))
  additionalArgs = args.splice(args.indexOf('--'), 9e9).slice(1);
options = {};
optionMap = {};
optionArguments = [
  [
    [
      'parse',
      'p'
    ],
    false,
    'output a JSON-serialised AST representation of the input'
  ],
  [
    [
      'compile',
      'c'
    ],
    false,
    'output a JSON-serialised AST representation of the output'
  ],
  [
    ['optimise'],
    true,
    'enable optimisations (default: on)'
  ],
  [
    ['debug'],
    false,
    'output intermediate representations on stderr for debug'
  ],
  [
    [
      'version',
      'v'
    ],
    false,
    'display the version number'
  ],
  [
    ['help'],
    false,
    'display this help message'
  ]
];
parameterArguments = [
  [
    ['cli'],
    'INPUT',
    'pass a string from the command line as input'
  ],
  [
    [
      'input',
      'i'
    ],
    'FILE',
    'file to be used as input instead of STDIN'
  ],
  [
    ['nodejs'],
    'OPTS',
    'pass options through to the node binary'
  ],
  [
    [
      'output',
      'o'
    ],
    'FILE',
    'file to be used as output instead of STDIN'
  ],
  [
    [
      'watch',
      'w'
    ],
    'FILE',
    'watch the given file/directory for changes'
  ]
];
if (null != escodegen) {
  [].push.apply(optionArguments, [
    [
      [
        'bare',
        'b'
      ],
      false,
      'omit the top-level function wrapper'
    ],
    [
      [
        'js',
        'j'
      ],
      false,
      'generate JavaScript output'
    ],
    [
      ['source-map'],
      false,
      'generate source map'
    ],
    [
      [
        'eval',
        'e'
      ],
      false,
      'evaluate compiled JavaScript'
    ],
    [
      ['repl'],
      false,
      'run an interactive CoffeeScript REPL'
    ]
  ]);
  if (null != uglifyjs)
    optionArguments.push([
      [
        'minify',
        'm'
      ],
      false,
      'run compiled javascript output through a JS minifier'
    ]);
  parameterArguments.push([
    [
      'require',
      'I'
    ],
    'FILE',
    'require a library before a script is executed'
  ]);
}
if (null != cscodegen)
  optionArguments.push([
    [
      'cscodegen',
      'f'
    ],
    false,
    'output cscodegen-generated CoffeeScript code'
  ]);
shortOptionArguments = [];
longOptionArguments = [];
for (var i$ = 0, length$ = optionArguments.length; i$ < length$; ++i$) {
  opts = optionArguments[i$];
  options[opts[0][0]] = opts[1];
  for (var i$1 = 0, length$1 = opts[0].length; i$1 < length$1; ++i$1) {
    o = opts[0][i$1];
    optionMap[o] = opts[0][0];
    if (o.length === 1) {
      shortOptionArguments.push(o);
    } else if (o.length > 1) {
      longOptionArguments.push(o);
    }
  }
}
shortParameterArguments = [];
longParameterArguments = [];
for (var i$2 = 0, length$2 = parameterArguments.length; i$2 < length$2; ++i$2) {
  opts = parameterArguments[i$2];
  for (var i$3 = 0, length$3 = opts[0].length; i$3 < length$3; ++i$3) {
    o = opts[0][i$3];
    optionMap[o] = opts[0][0];
    if (o.length === 1) {
      shortParameterArguments.push(o);
    } else if (o.length > 1) {
      longParameterArguments.push(o);
    }
  }
}
reShortOptions = new RegExp('^-(' + shortOptionArguments.join('|') + ')+$');
reLongOption = new RegExp('^--(no-)?(' + longOptionArguments.join('|') + ')$');
reShortParameter = new RegExp('^-(' + shortParameterArguments.join('|') + ')$');
reLongParameter = new RegExp('^--(' + longParameterArguments.join('|') + ')$');
reShortOptionsShortParameter = new RegExp('^-(' + shortOptionArguments.join('|') + ')+(' + shortParameterArguments.join('|') + ')$');
positionalArgs = [];
while (args.length) {
  arg = args.shift();
  if (reShortOptionsShortParameter.exec(arg)) {
    args.unshift('-' + arg.slice(1, -1), '-' + arg.slice(-1));
  } else if (reShortOptions.exec(arg)) {
    for (var cache$2 = arg.slice(1).split(''), i$4 = 0, length$4 = cache$2.length; i$4 < length$4; ++i$4) {
      o = cache$2[i$4];
      options[optionMap[o]] = true;
    }
  } else if (match = reLongOption.exec(arg)) {
    options[optionMap[match[2]]] = null != match[1] ? false : true;
  } else if (match = (cache$3 = reShortParameter.exec(arg), null != cache$3 ? cache$3 : reLongParameter.exec(arg))) {
    options[optionMap[match[1]]] = args.shift();
  } else if (match = /^(-.|--.*)$/.exec(arg)) {
    console.error("Unrecognised option '" + match[0].replace(/'/g, "\\'") + "'");
    process.exit(1);
  } else {
    positionalArgs.push(arg);
  }
}
positionalArgs = positionalArgs.concat(additionalArgs);
if (!(options.compile || options.js || options['source-map'] || options.parse || options['eval'] || options.cscodegen))
  if (!(null != escodegen)) {
    options.compile = true;
  } else if (positionalArgs.length) {
    options['eval'] = true;
    options.input = positionalArgs.shift();
    additionalArgs = positionalArgs;
  } else {
    options.repl = true;
  }
if (1 !== options.parse + options.compile + (null != options.js ? options.js : 0) + (null != options['source-map'] ? options['source-map'] : 0) + (null != options['eval'] ? options['eval'] : 0) + (null != options.cscodegen ? options.cscodegen : 0) + (null != options.repl ? options.repl : 0)) {
  console.error('Error: At most one of --parse (-p), --compile (-c), --js (-j), --source-map, --eval (-e), --cscodegen, or --repl may be used.');
  process.exit(1);
}
if (1 < (null != options.input) + (null != options.watch) + (null != options.cli)) {
  console.error('Error: At most one of --input (-i), --watch (-w), or --cli may be used.');
  process.exit(1);
}
if (null != options.require && !options['eval']) {
  console.error('Error: --require (-I) depends on --eval (-e)');
  process.exit(1);
}
if (options.minify && !(options.js || options['eval'])) {
  console.error('Error: --minify does not make sense without --js or --eval');
  process.exit(1);
}
if (options.bare && !(options.compile || options.js || options['source-map'] || options['eval'])) {
  console.error('Error: --bare does not make sense without --compile, --js, --source-map, or --eval');
  process.exit(1);
}
if (null != options.input && fs.statSync(options.input).isDirectory() && (!(null != options.output) || (null != (cache$4 = fs.statSync(options.output)) ? cache$4.isFile() : void 0)))
  console.error('Error: when --input is a directory, --output must be provided, and --output must not reference a file');
if (options.cscodegen && !(null != cscodegen)) {
  console.error('Error: cscodegen must be installed to use --cscodegen');
  process.exit(1);
}
if (options.help) {
  $0 = process.argv[0] === 'node' ? process.argv[1] : process.argv[0];
  $0 = path.basename($0);
  maxWidth = 85;
  wrap = function (lhsWidth, input) {
    var pad, rhsWidth, rows;
    rhsWidth = maxWidth - lhsWidth;
    pad = Array(lhsWidth + 4 + 1).join(' ');
    rows = function (accum$) {
      var row;
      while (input.length) {
        row = input.slice(0, rhsWidth);
        input = input.slice(rhsWidth);
        accum$.push(row);
      }
      return accum$;
    }.call(this, []);
    return rows.join('\n' + pad);
  };
  formatOptions = function (opts) {
    opts = function (accum$) {
      var opt;
      for (var i$5 = 0, length$5 = opts.length; i$5 < length$5; ++i$5) {
        opt = opts[i$5];
        if (!opt.length)
          continue;
        accum$.push(opt.length === 1 ? '-' + opt : '--' + opt);
      }
      return accum$;
    }.call(this, []);
    opts.sort(function (a, b) {
      return a.length - b.length;
    });
    return opts.join(', ');
  };
  console.log('\n    Usage:\n      ' + $0 + ' FILE ARG* [-- ARG*]\n      ' + $0 + ' OPT* [--repl] OPT*\n      ' + $0 + ' OPT* -{-parse,p,-compile,c,-js,j,-cscodegen} OPT*\n      ' + $0 + ' {OPT,ARG}* -{-eval,e} {OPT,ARG}* -- ARG*\n\n  ');
  optionRows = function (accum$) {
    var opt;
    for (var i$5 = 0, length$5 = optionArguments.length; i$5 < length$5; ++i$5) {
      opt = optionArguments[i$5];
      accum$.push([
        formatOptions(opt[0]),
        opt[2]
      ]);
    }
    return accum$;
  }.call(this, []);
  parameterRows = function (accum$) {
    var opt;
    for (var i$5 = 0, length$5 = parameterArguments.length; i$5 < length$5; ++i$5) {
      opt = parameterArguments[i$5];
      accum$.push([
        '' + formatOptions(opt[0]) + ' ' + opt[1],
        opt[2]
      ]);
    }
    return accum$;
  }.call(this, []);
  leftColumnWidth = foldl(0, [].slice.call(optionRows).concat([].slice.call(parameterRows)), function (memo, opt) {
    return Math.max(memo, opt[0].length);
  });
  rows = [].slice.call(optionRows).concat([].slice.call(parameterRows));
  rows.sort(function (a, b) {
    a = a[0];
    b = b[0];
    if (a.slice(0, +1 + 1) === '--' && b.slice(0, +1 + 1) !== '--')
      return 1;
    if (b.slice(0, +1 + 1) === '--' && a.slice(0, +1 + 1) !== '--')
      return -1;
    if (a.toLowerCase() < b.toLowerCase()) {
      return -1;
    } else {
      return 1;
    }
  });
  for (var i$5 = 0, length$5 = rows.length; i$5 < length$5; ++i$5) {
    row = rows[i$5];
    console.log('  ' + row[0] + Array(leftColumnWidth - row[0].length + 1).join(' ') + '  ' + wrap(leftColumnWidth, row[1]));
  }
  console.log('\n\n    Unless instructed otherwise (--{input,watch,cli}), `' + $0 + '` will operate on stdin/stdout.\n    When none of -{-parse,p,-compile,c,-js,j,-eval,e,-cscodegen,-repl} are given\n      If positional arguments were given\n        * --eval is implied\n        * the first positional argument is used as an input filename\n        * additional positional arguments are passed as arguments to the script\n      Else --repl is implied\n  ');
} else if (options.version) {
  pkg = require('./../../package.json');
  console.log('CoffeeScript version ' + pkg.version);
} else if (options.repl) {
  console.error('TODO: REPL');
  process.exit(1);
} else {
  input = '';
  processInput = function (err) {
    var d, domain, e, evalFn, js, jsAST, result, sourceMap;
    if (null != err)
      throw err;
    result = null;
    input = input.toString();
    if (65279 === input.charCodeAt(0))
      input = input.slice(1);
    if (options.debug)
      try {
        console.error('### PREPROCESSED CS ###');
        console.error(numberLines(humanReadable(Preprocessor.processSync(input))));
      } catch (e$) {
      }
    try {
      result = CoffeeScript.parse(input, { optimise: false });
    } catch (e$1) {
      e = e$1;
      console.error(e.message);
      process.exit(1);
    }
    if (options.debug && options.optimise && null != result) {
      console.error('### PARSED CS-AST ###');
      console.error(inspect(result.toJSON()));
    }
    if (options.optimise && null != result)
      result = Optimiser.optimise(result);
    if (options.parse)
      if (null != result) {
        console.log(inspect(result.toJSON()));
        process.exit(0);
      } else {
        process.exit(1);
      }
    if (options.debug && null != result) {
      console.error('### ' + (options.optimise ? 'OPTIMISED' : 'PARSED') + ' CS-AST ###');
      console.error(inspect(result.toJSON()));
    }
    if (options.cscodegen) {
      try {
        result = cscodegen.generate(result);
      } catch (e$2) {
        e = e$2;
        console.error(e.stack || e.message);
        process.exit(1);
      }
      if (null != result) {
        console.log(result);
        process.exit(0);
      } else {
        process.exit(1);
      }
    }
    jsAST = CoffeeScript.compile(result, { bare: options.bare });
    if (options.compile)
      if (null != jsAST) {
        console.log(inspect(jsAST.toJSON()));
        process.exit(0);
      } else {
        process.exit(1);
      }
    if (options.debug && null != jsAST) {
      console.error('### COMPILED JS-AST ###');
      console.error(inspect(jsAST.toJSON()));
    }
    if (options['source-map']) {
      try {
        sourceMap = CoffeeScript.sourceMap(jsAST, null != options.input ? options.input : options.cli && 'cli' || 'stdin');
      } catch (e$3) {
        e = e$3;
        console.error(e.stack || e.message);
        process.exit(1);
      }
      if (null != sourceMap) {
        process.stdout.write('' + sourceMap + '\n');
        process.exit(0);
      } else {
        process.exit(1);
      }
    } else {
      try {
        js = CoffeeScript.js(jsAST, { minify: false });
      } catch (e$4) {
        e = e$4;
        console.error(e.stack || e.message);
        process.exit(1);
      }
    }
    if (options.minify && null != js)
      try {
        js = uglifyjs.uglify.gen_code(uglifyjs.uglify.ast_squeeze(uglifyjs.uglify.ast_mangle(uglifyjs.parser.parse(js))));
      } catch (e$5) {
        e = e$5;
        console.error(e.stack || e.message);
        process.exit(1);
      }
    if (options.js)
      if (null != js) {
        console.log(js);
        process.exit(0);
      } else {
        process.exit(1);
      }
    if (options['eval']) {
      evalFn = function () {
        return (0, eval)(js);
      };
      domain = function () {
        try {
          return require('domain');
        } catch (e$6) {
          return;
        }
      }.call(this);
      if (null != domain) {
        d = domain.create();
        d.on('error', function (err) {
          var SourceMapConsumer;
          SourceMapConsumer = require('source-map').SourceMapConsumer;
          Error.prepareStackTrace = function (err, stack) {
            var errorPos, frames, originalLine;
            sourceMap = new SourceMapConsumer(CoffeeScript.sourceMap(jsAST, null != options.input ? options.input : options.cli && 'cli' || 'stdin'));
            frames = stack.map(function (frame) {
              var cache$5, column, filename, line, name, source;
              name = (cache$5 = frame.getFunctionName(), null != cache$5 ? cache$5 : '(unknown)');
              line = frame.getLineNumber();
              column = frame.getColumnNumber();
              filename = frame.getFileName();
              if (null != filename) {
                return '  at ' + name + ' (' + filename + ':' + line + ':' + column + ')';
              } else {
                source = sourceMap.originalPositionFor({
                  line: line,
                  column: column
                });
                return '  at ' + name + ' (' + (null != options.input ? options.input : '<input>') + ':' + source.line + ':' + source.column + ', <js>:' + line + ':' + column + ')';
              }
            });
            errorPos = sourceMap.originalPositionFor({
              line: stack[0].getLineNumber(),
              column: stack[0].getColumnNumber()
            });
            originalLine = input.split('\n')[errorPos.line - 1];
            return [
              'ERROR: ' + err.message,
              '',
              '' + errorPos.line + ': ' + originalLine,
              '' + errorPos.line.toString().replace(/./, '^') + ': ' + Array(errorPos.column).join('~') + '^',
              '',
              frames.join('\n')
            ].join('\n');
          };
          return console.error(err.stack);
        });
        return d.run(evalFn);
      } else {
        return process.nextTick(evalFn);
      }
    }
  };
  if (null != options.input) {
    fs.stat(options.input, function (err, stats) {
      if (null != err)
        throw err;
      if (stats.isDirectory())
        options.input = path.join(options.input, 'index.coffee');
      return fs.readFile(options.input, function (err, contents) {
        if (null != err)
          throw err;
        input = contents;
        return processInput();
      });
    });
  } else if (null != options.watch) {
    options.watch;
  } else if (null != options.cli) {
    input = options.cli;
    processInput();
  } else {
    process.stdin.on('data', function (data) {
      return input += data;
    });
    process.stdin.on('end', processInput);
    process.stdin.setEncoding('utf8');
    process.stdin.resume();
  }
}
function in$(member, list) {
  for (var i = 0, length = list.length; i < length; ++i)
    if (i in list && list[i] === member)
      return true;
  return false;
}

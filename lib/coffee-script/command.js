// Generated by CoffeeScript 2.0.0-beta1
var CoffeeScript, cscodegen, esmangle, fs, humanReadable, input, input, inputSource, inspect, numberLines, Optimiser, options, optionsProcessor, path, Preprocessor, processInput, Repl, runMain, writeOutput;
fs = require('fs');
path = require('path');
cache$ = require('./helpers');
numberLines = cache$.numberLines;
humanReadable = cache$.humanReadable;
inspect = cache$.inspect;
Preprocessor = require('./preprocessor').Preprocessor;
Optimiser = require('./optimiser').Optimiser;
runMain = require('./run').runMain;
CoffeeScript = require('./module');
Repl = require('./repl');
optionsProcessor = require('./cli-options');
cscodegen = function () {
  try {
    return require('cscodegen');
  } catch (e$) {
    return;
  }
}.call(this);
esmangle = function () {
  try {
    return require('esmangle');
  } catch (e$) {
    return;
  }
}.call(this);
options = optionsProcessor.process(process.argv);
writeOutput = function (type, contents) {
  var outputFilename;
  if (!(null != contents))
    throw Error('Failed to generate output for [' + type + ']');
  if (options[type] === '(stdout)') {
    return console.log(contents);
  } else {
    outputFilename = options[type];
    return fs.writeFile(outputFilename, contents, function (err) {
      if (null != err)
        throw err;
    });
  }
};
String.prototype.updateURLs = function (path_to_modify) {
  var content;
  content = this;
  return {
    relativeTo: function (base_path) {
      var base_path_parts, part, path_to_modify_parts;
      path_to_modify_parts = path_to_modify.split('/');
      base_path_parts = base_path.split('/');
      base_path_parts.pop();
      while (path_to_modify_parts.length) {
        if (path_to_modify_parts[0] !== base_path_parts[0])
          break;
        path_to_modify_parts.shift();
        base_path_parts.shift();
      }
      for (var i$ = 0, length$ = base_path_parts.length; i$ < length$; ++i$) {
        part = base_path_parts[i$];
        path_to_modify_parts.unshift('..');
      }
      return content.replace(new RegExp(path_to_modify, 'g'), path_to_modify_parts.join('/'));
    }
  };
};
if (options.repl) {
  Repl.start();
} else {
  input = '';
  inputSource = null != options.input ? fs.realpathSync(options.input) : options.cli && '(cli)' || '(stdin)';
  processInput = function (err) {
    var cscodegen_result, e, js, jsAST, jsOutput, result, sourceMap;
    if (null != err)
      throw err;
    result = null;
    input = input.toString();
    if (65279 === input.charCodeAt(0))
      input = input.slice(1);
    if (options.debug)
      try {
        console.error('### PREPROCESSED CS ###');
        console.error(numberLines(humanReadable(Preprocessor.processSync(input))));
      } catch (e$) {
      }
    try {
      result = CoffeeScript.parse(input, {
        optimise: false,
        raw: options.raw || options['source-map'] || options['eval'],
        inputSource: inputSource
      });
    } catch (e$1) {
      e = e$1;
      console.error(e.message);
      process.exit(1);
    }
    if (options.debug && options.optimise && null != result) {
      console.error('### PARSED CS-AST ###');
      console.error(inspect(result.toJSON()));
    }
    if (options.optimise && null != result) {
      result = Optimiser.optimise(result);
      if (options.debug) {
        console.error('### OPTIMISED CS-AST ###');
        console.error(inspect(result.toJSON()));
      }
    }
    if (options.parse)
      writeOutput('parse', inspect(result.toJSON()));
    if (options.cscodegen) {
      try {
        cscodegen_result = cscodegen.generate(result);
      } catch (e$2) {
        e = e$2;
        console.error(e.stack || e.message);
        process.exit(1);
      }
      writeOutput('cscodegen', cscodegen_result);
    }
    jsAST = CoffeeScript.compile(result, { bare: options.bare });
    if (options.compile)
      writeOutput('compile', inspect(jsAST.toJSON()));
    if (options.debug) {
      console.error('### COMPILED JS-AST ###');
      console.error(inspect(jsAST.toJSON()));
    }
    if (options['source-map']) {
      try {
        sourceMap = CoffeeScript.sourceMap(jsAST, null != options.input ? options.input : options.cli && 'cli' || 'stdin', { compact: options.minify });
      } catch (e$3) {
        e = e$3;
        console.error(e.stack || e.message);
        process.exit(1);
      }
      writeOutput('source-map', sourceMap.updateURLs(options.input).relativeTo(options['source-map']));
    }
    if (options['minify-destructive'])
      try {
        jsAST = esmangle.mangle(esmangle.optimize(jsAST.toJSON()), { destructive: true });
      } catch (e$4) {
        e = e$4;
        console.error(e.stack || e.message);
        process.exit(1);
      }
    try {
      js = CoffeeScript.js(jsAST, { compact: options.minify });
    } catch (e$5) {
      e = e$5;
      console.error(e.stack || e.message);
      process.exit(1);
    }
    if (options.js) {
      jsOutput = js;
      if (null != options.input && options['include-source-reference'])
        if (options['source-map'] && options['source-map'] !== '(stdout)' && options.js && options.js !== '(stdout)') {
          jsOutput = '' + jsOutput + '\n//@ sourceMappingURL=' + options['source-map'].updateURLs(options['source-map']).relativeTo(options.js);
        } else {
          jsOutput = '' + jsOutput + '\n//@ sourceURL=' + options.input;
        }
      return writeOutput('js', jsOutput);
    } else if (options['eval']) {
      return runMain(input, js, jsAST, inputSource);
    }
  };
  if (null != options.input) {
    fs.stat(options.input, function (err, stats) {
      if (null != err)
        throw err;
      if (stats.isDirectory())
        options.input = path.join(options.input, 'index.coffee');
      return fs.readFile(options.input, function (err, contents) {
        if (null != err)
          throw err;
        input = contents;
        return processInput();
      });
    });
  } else if (null != options.watch) {
    options.watch;
  } else if (null != options.cli) {
    input = options.cli;
    processInput();
  } else {
    process.stdin.on('data', function (data) {
      return input += data;
    });
    process.stdin.on('end', processInput);
    process.stdin.setEncoding('utf8');
    process.stdin.resume();
  }
}
//@ sourceURL=src/command.coffee

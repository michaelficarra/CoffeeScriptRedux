// Generated by CoffeeScript 1.3.3
var $0, CoffeeScript, Optimiser, Preprocessor, additionalArgs, arg, args, concat, cscodegen, escodegen, filename, foldl, formatOptions, fs, humanReadable, input, inspect, leftColumnWidth, longOptionArguments, longParameterArguments, match, maxWidth, numberLines, o, opt, optionArguments, optionMap, optionRows, options, opts, parameterArguments, parameterRows, path, positionalArgs, processInput, reLongOption, reLongParameter, reShortOptions, reShortOptionsShortParameter, reShortParameter, row, rows, shortOptionArguments, shortParameterArguments, uglifyjs, wrap, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  __slice = [].slice;

fs = require('fs');

path = require('path');

_ref = require('./functional-helpers'), concat = _ref.concat, foldl = _ref.foldl;

Preprocessor = require('./preprocessor').Preprocessor;

Optimiser = require('./optimiser').Optimiser;

CoffeeScript = require('./module');

cscodegen = (function() {
  try {
    return require('cscodegen');
  } catch (_error) {}
})();

escodegen = (function() {
  try {
    return require('escodegen');
  } catch (_error) {}
})();

uglifyjs = (function() {
  try {
    return require('uglify-js');
  } catch (_error) {}
})();

inspect = function(o) {
  return (require('util')).inspect(o, false, 9e9, true);
};

humanReadable = function(str) {
  return (str.replace(/\uEFEF/g, '(INDENT)')).replace(/\uEFFE\uEFFF/g, '(DEDENT)');
};

numberLines = function(input, startLine) {
  var currLine, i, line, lines, numbered, pad, padSize;
  if (startLine == null) {
    startLine = 1;
  }
  lines = input.split('\n');
  padSize = ((lines.length + startLine - 1).toString(10)).length;
  numbered = (function() {
    var _i, _len, _results;
    _results = [];
    for (i = _i = 0, _len = lines.length; _i < _len; i = ++_i) {
      line = lines[i];
      currLine = "" + (i + startLine);
      pad = (Array(padSize + 1).join('0')).slice(currLine.length);
      _results.push("" + pad + currLine + " : " + lines[i]);
    }
    return _results;
  })();
  return numbered.join('\n');
};

args = process.argv.slice(1 + (process.argv[0] === 'node'));

additionalArgs = [];

if (__indexOf.call(args, '--') >= 0) {
  additionalArgs = args.splice(args.indexOf('--'), 9e9);
}

options = {};

optionMap = {};

optionArguments = [[['parse', 'p'], false, 'output a JSON-serialised AST representation of the input'], [['compile', 'c'], false, 'output a JSON-serialised AST representation of the output'], [['optimise'], true, 'enable optimisations (default: on)'], [['debug'], false, 'output intermediate representations on stderr for debug'], [['version', 'v'], false, 'display the version number'], [['help'], false, 'display this help message']];

parameterArguments = [[['cli'], 'INPUT', 'pass a string from the command line as input'], [['input', 'i'], 'FILE', 'file to be used as input instead of STDIN'], [['nodejs'], 'OPTS', 'pass options through to the node binary'], [['output', 'o'], 'FILE', 'file to be used as output instead of STDIN'], [['watch', 'w'], 'FILE', 'watch the given file/directory for changes']];

if (escodegen != null) {
  [].push.apply(optionArguments, [[['bare', 'b'], false, 'omit the top-level function wrapper'], [['js', 'j'], false, 'generate JavaScript output'], [['eval', 'e'], false, 'evaluate compiled JavaScript'], [['repl'], false, 'run an interactive CoffeeScript REPL']]);
  if (uglifyjs != null) {
    optionArguments.push([['minify', 'm'], false, 'run compiled javascript output through a JS minifier']);
  }
  parameterArguments.push([['require', 'I'], 'FILE', 'require a library before a script is executed']);
}

if (cscodegen != null) {
  optionArguments.push([['cscodegen', 'f'], false, 'output cscodegen-generated CoffeeScript code']);
}

shortOptionArguments = [];

longOptionArguments = [];

for (_i = 0, _len = optionArguments.length; _i < _len; _i++) {
  opts = optionArguments[_i];
  options[opts[0][0]] = opts[1];
  _ref1 = opts[0];
  for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
    o = _ref1[_j];
    optionMap[o] = opts[0][0];
    if (o.length === 1) {
      shortOptionArguments.push(o);
    } else if (o.length > 1) {
      longOptionArguments.push(o);
    }
  }
}

shortParameterArguments = [];

longParameterArguments = [];

for (_k = 0, _len2 = parameterArguments.length; _k < _len2; _k++) {
  opts = parameterArguments[_k];
  _ref2 = opts[0];
  for (_l = 0, _len3 = _ref2.length; _l < _len3; _l++) {
    o = _ref2[_l];
    optionMap[o] = opts[0][0];
    if (o.length === 1) {
      shortParameterArguments.push(o);
    } else if (o.length > 1) {
      longParameterArguments.push(o);
    }
  }
}

reShortOptions = RegExp("^-(" + (shortOptionArguments.join('|')) + ")+$");

reLongOption = RegExp("^--(no-)?(" + (longOptionArguments.join('|')) + ")$");

reShortParameter = RegExp("^-(" + (shortParameterArguments.join('|')) + ")$");

reLongParameter = RegExp("^--(" + (longParameterArguments.join('|')) + ")$");

reShortOptionsShortParameter = RegExp("^-(" + (shortOptionArguments.join('|')) + ")+(" + (shortParameterArguments.join('|')) + ")$");

positionalArgs = [];

while (args.length) {
  arg = args.shift();
  if (reShortOptionsShortParameter.exec(arg)) {
    args.unshift("-" + arg.slice(1, -1), "-" + arg.slice(-1));
  } else if (reShortOptions.exec(arg)) {
    _ref3 = arg.slice(1).split('');
    for (_m = 0, _len4 = _ref3.length; _m < _len4; _m++) {
      o = _ref3[_m];
      options[optionMap[o]] = true;
    }
  } else if (match = reLongOption.exec(arg)) {
    options[optionMap[match[2]]] = match[1] != null ? false : true;
  } else if (match = (_ref4 = reShortParameter.exec(arg)) != null ? _ref4 : reLongParameter.exec(arg)) {
    options[optionMap[match[1]]] = args.shift();
  } else {
    positionalArgs.push(arg);
  }
}

if (!(options.compile || options.js || options.parse || options["eval"] || options.cscodegen)) {
  if (!(escodegen != null)) {
    options.compile = true;
  } else if (positionalArgs.length) {
    options["eval"] = true;
    options.input = positionalArgs.shift();
    additionalArgs = __slice.call(positionalArgs).concat(__slice.call(additionalArgs));
  } else {
    options.repl = true;
  }
}

if (1 !== options.parse + options.compile + ((_ref5 = options.js) != null ? _ref5 : 0) + ((_ref6 = options["eval"]) != null ? _ref6 : 0) + ((_ref7 = options.cscodegen) != null ? _ref7 : 0) + ((_ref8 = options.repl) != null ? _ref8 : 0)) {
  console.error("Error: At most one of --parse (-p), --compile (-c), --js (-j), --eval (-e), --cscodegen, or --repl may be used.");
  process.exit(1);
}

if (1 < (options.input != null) + (options.watch != null) + (options.cli != null)) {
  console.error('Error: At most one of --input (-i), --watch (-w), or --cli may be used.');
  process.exit(1);
}

if ((options.require != null) && !options["eval"]) {
  console.error('Error: --require (-I) depends on --eval (-e)');
  process.exit(1);
}

if (options.minify && !(options.js || options["eval"])) {
  console.error('Error: --minify does not make sense without --js or --eval');
  process.exit(1);
}

if (options.bare && !(options.compile || options.js || options["eval"])) {
  console.error('Error: --bare does not make sense without --compile, --js, or --eval');
  process.exit(1);
}

if ((options.input != null) && (fs.statSync(options.input)).isDirectory() && (!(options.output != null) || ((_ref9 = fs.statSync(options.output)) != null ? _ref9.isFile() : void 0))) {
  console.error('Error: when --input is a directory, --output must be provided, and --output must not reference a file');
}

if (options.cscodegen && !(cscodegen != null)) {
  console.error('Error: cscodegen must be installed to use --cscodegen');
  process.exit(1);
}

if (options.help) {
  $0 = process.argv[0] === 'node' ? process.argv[1] : process.argv[0];
  $0 = path.basename($0);
  maxWidth = 85;
  wrap = function(lhsWidth, input) {
    var pad, rhsWidth, row, rows;
    rhsWidth = maxWidth - lhsWidth;
    pad = (Array(lhsWidth + 4 + 1)).join(' ');
    rows = (function() {
      var _results;
      _results = [];
      while (input.length) {
        row = input.slice(0, rhsWidth);
        input = input.slice(rhsWidth);
        _results.push(row);
      }
      return _results;
    })();
    return rows.join("\n" + pad);
  };
  formatOptions = function(opts) {
    var opt;
    opts = (function() {
      var _len5, _n, _results;
      _results = [];
      for (_n = 0, _len5 = opts.length; _n < _len5; _n++) {
        opt = opts[_n];
        switch (opt.length) {
          case 0:
            continue;
          case 1:
            _results.push("-" + opt);
            break;
          default:
            _results.push("--" + opt);
        }
      }
      return _results;
    })();
    opts.sort(function(a, b) {
      return a.length - b.length;
    });
    return opts.join(', ');
  };
  console.log("Usage:\n  " + $0 + " FILE ARG* [-- ARG*]\n  " + $0 + " OPT* [--repl] OPT*\n  " + $0 + " OPT* -{-parse,p,-compile,c,-js,j,-cscodegen} OPT*\n  " + $0 + " {OPT,ARG}* -{-eval,e} {OPT,ARG}* -- ARG*\n");
  optionRows = (function() {
    var _len5, _n, _results;
    _results = [];
    for (_n = 0, _len5 = optionArguments.length; _n < _len5; _n++) {
      opt = optionArguments[_n];
      _results.push([formatOptions(opt[0]), opt[2]]);
    }
    return _results;
  })();
  parameterRows = (function() {
    var _len5, _n, _results;
    _results = [];
    for (_n = 0, _len5 = parameterArguments.length; _n < _len5; _n++) {
      opt = parameterArguments[_n];
      _results.push(["" + (formatOptions(opt[0])) + " " + opt[1], opt[2]]);
    }
    return _results;
  })();
  leftColumnWidth = foldl(0, __slice.call(optionRows).concat(__slice.call(parameterRows)), function(memo, opt) {
    return Math.max(memo, opt[0].length);
  });
  rows = __slice.call(optionRows).concat(__slice.call(parameterRows));
  rows.sort(function(a, b) {
    a = a[0];
    b = b[0];
    if (a.slice(0, 2) === '--' && b.slice(0, 2) !== '--') {
      return 1;
    }
    if (b.slice(0, 2) === '--' && a.slice(0, 2) !== '--') {
      return -1;
    }
    if (a.toLowerCase() < b.toLowerCase()) {
      return -1;
    } else {
      return 1;
    }
  });
  for (_n = 0, _len5 = rows.length; _n < _len5; _n++) {
    row = rows[_n];
    console.log("  " + row[0] + ((Array(leftColumnWidth - row[0].length + 1)).join(' ')) + "  " + (wrap(leftColumnWidth, row[1])));
  }
  console.log("\nUnless instructed otherwise (--{input,watch,cli}), `" + $0 + "` will operate on stdin/stdout.\nWhen none of -{-parse,p,-compile,c,-js,j,-eval,e,-cscodegen,-repl} are given\n  If positional arguments were given\n    * --eval is implied\n    * the first positional argument is used as an input filename\n    * additional positional arguments are passed as arguments to the script\n  Else --repl is implied");
} else if (options.version) {
  filename = path.join(__dirname, '..', '..', 'package.json');
  fs.readFile(filename, function(err, pkg) {
    if (err) {
      throw err;
    }
    return console.log("CoffeeScript version " + (JSON.parse(pkg)).version);
  });
} else if (options.repl) {
  console.log('TODO: REPL');
} else {
  input = '';
  processInput = function(err) {
    var result;
    if (err != null) {
      throw err;
    }
    result = null;
    input = input.toString();
    if (0xFEFF === input.charCodeAt(0)) {
      input = input.slice(1);
    }
    if (options.debug) {
      Preprocessor.processSync(input);
      console.error('### PREPROCESSED CS-AST ###');
      console.error(numberLines(humanReadable(input.trim())));
    }
    result = CoffeeScript.parse(input, {
      optimise: false
    });
    if (options.debug && options.optimise && (result != null)) {
      console.error('### PARSED CS-AST ###');
      console.error(inspect(result.toJSON()));
    }
    if (options.optimise && (result != null)) {
      result = Optimiser.optimise(result);
    }
    if (options.parse) {
      if (result != null) {
        console.log(inspect(result.toJSON()));
        process.exit(0);
      } else {
        process.exit(1);
      }
    }
    if (options.debug && (result != null)) {
      console.error("### " + (options.optimise ? 'OPTIMISED' : 'PARSED') + " CS-AST ###");
      console.error(inspect(result.toJSON()));
    }
    if (options.cscodegen) {
      try {
        result = cscodegen.generate(result);
      } catch (e) {
        console.error(e.stack || e.message);
        process.exit(1);
      }
      if (result != null) {
        console.log(result);
        process.exit(0);
      } else {
        process.exit(1);
      }
    }
    result = CoffeeScript.compile(result, {
      bare: options.bare
    });
    if (options.compile) {
      if (result != null) {
        console.log(inspect(result.toJSON()));
        process.exit(0);
      } else {
        process.exit(1);
      }
    }
    if (options.debug && (result != null)) {
      console.error("### COMPILED JS-AST ###");
      console.error(inspect(result.toJSON()));
    }
    try {
      result = CoffeeScript.js(result, {
        minify: false
      });
    } catch (e) {
      console.error(e.stack || e.message);
      process.exit(1);
    }
    if (options.minify && (result != null)) {
      try {
        result = uglifyjs.uglify.gen_code(uglifyjs.uglify.ast_squeeze(uglifyjs.uglify.ast_mangle(uglifyjs.parser.parse(result))));
      } catch (e) {
        console.error(e.stack || e.message);
        process.exit(1);
      }
    }
    if (options.js) {
      if (result != null) {
        console.log(result);
        process.exit(0);
      } else {
        process.exit(1);
      }
    }
    if (options["eval"]) {
      return (function() {
        return (0, eval)(result);
      })();
    }
  };
  if (options.input != null) {
    fs.readFile(options.input, function(err, contents) {
      if (err != null) {
        throw err;
      }
      input = contents;
      return processInput();
    });
  } else if (options.watch != null) {

  } else if (options.cli != null) {
    input = options.cli;
    processInput();
  } else {
    process.stdin.on('data', function(data) {
      return input += data;
    });
    process.stdin.on('end', processInput);
    process.stdin.setEncoding('utf8');
    process.stdin.resume();
  }
}

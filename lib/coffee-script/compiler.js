// Generated by CoffeeScript 1.3.3
var CS, JS, any, beingDeclared, collectIdentifiers, concat, concatMap, declarationsNeeded, declarationsNeededRecursive, difference, divMod, dynamicMemberAccess, enabledHelpers, envEnrichments, exports, expr, fn, foldl1, forceBlock, genSym, generateMutatingWalker, h, handleSpecialParam, helperNames, helpers, inlineHelpers, jsReserved, makeReturn, makeVarDeclaration, map, memberAccess, needsCaching, nub, owns, stmt, union, usedAsExpression, _ref, _ref1, _ref2,
  __slice = [].slice,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  __hasProp = {}.hasOwnProperty;

_ref = require('./functional-helpers'), any = _ref.any, concat = _ref.concat, concatMap = _ref.concatMap, difference = _ref.difference, divMod = _ref.divMod, foldl1 = _ref.foldl1, map = _ref.map, nub = _ref.nub, owns = _ref.owns, union = _ref.union;

_ref1 = require('./helpers'), beingDeclared = _ref1.beingDeclared, usedAsExpression = _ref1.usedAsExpression, envEnrichments = _ref1.envEnrichments;

CS = require('./nodes');

JS = require('./js-nodes');

exports = (_ref2 = typeof module !== "undefined" && module !== null ? module.exports : void 0) != null ? _ref2 : this;

jsReserved = ['break', 'case', 'catch', 'class', 'const', 'continue', 'debugger', 'default', 'delete', 'do', 'else', 'enum', 'export', 'extends', 'false', 'finally', 'for', 'function', 'if', 'implements', 'import', 'in', 'instanceof', 'interface', 'let', 'native', 'new', 'null', 'package', 'private', 'protected', 'public', 'return', 'static', 'super', 'switch', 'this', 'throw', 'true', 'try', 'typeof', 'var', 'void', 'while', 'with', 'yield', 'arguments', 'eval'];

genSym = (function() {
  var genSymCounter;
  genSymCounter = 0;
  return function(pre) {
    return new JS.GenSym(pre, ++genSymCounter);
  };
})();

stmt = function(e) {
  var walk;
  if (e == null) {
    return e;
  }
  if (e.isStatement) {
    return e;
  } else if (e["instanceof"](JS.SequenceExpression)) {
    walk = function(seq) {
      return concatMap(seq.expressions, function(e) {
        if (e["instanceof"](JS.SequenceExpression)) {
          return walk(e);
        } else {
          return [stmt(e)];
        }
      });
    };
    return new JS.BlockStatement(walk(e));
  } else if (e["instanceof"](JS.ConditionalExpression)) {
    return new JS.IfStatement(expr(e.test), stmt(e.consequent), stmt(e.alternate));
  } else {
    return new JS.ExpressionStatement(e);
  }
};

expr = function(s) {
  var accum, alternate, block, consequent, iife, push, _ref3, _ref4;
  if (s == null) {
    return s;
  }
  if (s.isExpression) {
    return s;
  } else if (s["instanceof"](JS.BlockStatement)) {
    switch (s.body.length) {
      case 0:
        return helpers.undef();
      case 1:
        return expr(s.body[0]);
      default:
        return new JS.SequenceExpression(map(s.body, expr));
    }
  } else if (s["instanceof"](JS.BreakStatement, JS.ContinueStatement, JS.ReturnStatement)) {
    throw new Error("pure statement in an expression");
  } else if (s["instanceof"](JS.ExpressionStatement)) {
    return s.expression;
  } else if (s["instanceof"](JS.IfStatement)) {
    consequent = expr((_ref3 = s.consequent) != null ? _ref3 : helpers.undef());
    alternate = expr((_ref4 = s.alternate) != null ? _ref4 : helpers.undef());
    return new JS.ConditionalExpression(s.test, consequent, alternate);
  } else if (s["instanceof"](JS.ForInStatement, JS.ForStatement, JS.WhileStatement)) {
    accum = genSym('accum');
    s.body = forceBlock(s.body);
    push = memberAccess(accum, 'push');
    s.body.body[s.body.body.length - 1] = stmt(new JS.CallExpression(push, [expr(s.body.body.slice(-1)[0])]));
    block = new JS.BlockStatement([s, new JS.ReturnStatement(accum)]);
    iife = new JS.FunctionExpression(null, [accum], block);
    return new JS.CallExpression(memberAccess(iife, 'call'), [new JS.ThisExpression, new JS.ArrayExpression([])]);
  } else if (s["instanceof"](JS.SwitchStatement)) {
    block = new JS.BlockStatement([makeReturn(s)]);
    iife = new JS.FunctionExpression(null, [], block);
    return new JS.CallExpression(memberAccess(iife, 'call'), [new JS.ThisExpression]);
  } else {
    throw new Error("expr: " + s.type);
  }
};

makeReturn = function(node) {
  var stmts;
  if (node == null) {
    return new JS.ReturnStatement;
  }
  if (node["instanceof"](JS.BlockStatement)) {
    return new JS.BlockStatement(__slice.call(node.body.slice(0, -1)).concat([makeReturn(node.body.slice(-1)[0])]));
  } else if (node["instanceof"](JS.SequenceExpression)) {
    return new JS.SequenceExpression(__slice.call(node.expressions.slice(0, -1)).concat([makeReturn(node.expressions.slice(-1)[0])]));
  } else if (node["instanceof"](JS.IfStatement)) {
    return new JS.IfStatement(node.test, makeReturn(node.consequent), node.alternate != null ? makeReturn(node.alternate) : null);
  } else if (node["instanceof"](JS.SwitchStatement)) {
    return new JS.SwitchStatement(node.discriminant, map(node.cases, makeReturn));
  } else if (node["instanceof"](JS.SwitchCase)) {
    if (!node.consequent.length) {
      return node;
    }
    stmts = node.consequent.slice(-1)[0]["instanceof"](JS.BreakStatement) ? node.consequent.slice(0, -1) : node.consequent;
    return new JS.SwitchCase(node.test, __slice.call(stmts.slice(0, -1)).concat([makeReturn(stmts.slice(-1)[0])]));
  } else if (node["instanceof"](JS.ThrowStatement, JS.ReturnStatement, JS.BreakStatement, JS.ContinueStatement)) {
    return node;
  } else if ((node["instanceof"](JS.UnaryExpression)) && node.operator === 'void') {
    return new JS.ReturnStatement;
  } else {
    return new JS.ReturnStatement(expr(node));
  }
};

generateMutatingWalker = function(fn) {
  return function() {
    var args, childName, n, node, _i, _len, _ref3;
    node = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    _ref3 = node.childNodes;
    for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
      childName = _ref3[_i];
      if (node[childName] == null) {
        continue;
      }
      node[childName] = (function() {
        var _j, _len1, _ref4, _results;
        if (__indexOf.call(node.listMembers, childName) >= 0) {
          _ref4 = node[childName];
          _results = [];
          for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
            n = _ref4[_j];
            _results.push(fn.apply(n, args));
          }
          return _results;
        } else {
          return fn.apply(node[childName], args);
        }
      })();
    }
    return node;
  };
};

declarationsNeeded = function(node) {
  if (node == null) {
    return [];
  }
  if ((node["instanceof"](JS.AssignmentExpression)) && node.operator === '=' && node.left["instanceof"](JS.Identifier)) {
    return [node.left];
  } else if (node["instanceof"](JS.ForInStatement)) {
    return [node.left];
  } else {
    return [];
  }
};

declarationsNeededRecursive = function(node) {
  if (node == null) {
    return [];
  }
  if (node["instanceof"](JS.FunctionExpression, JS.FunctionDeclaration)) {
    return [];
  } else {
    return union(declarationsNeeded(node), concatMap(node.childNodes, function(childName) {
      if (node[childName] == null) {
        return [];
      }
      if (__indexOf.call(node.listMembers, childName) >= 0) {
        return concatMap(node[childName], declarationsNeededRecursive);
      } else {
        return declarationsNeededRecursive(node[childName]);
      }
    }));
  }
};

collectIdentifiers = function(node) {
  return nub((function() {
    switch (false) {
      case !!(node != null):
        return [];
      case !node["instanceof"](JS.Identifier):
        return [node.name];
      case !((node["instanceof"](JS.MemberExpression)) && !node.computed):
        return collectIdentifiers(node.object);
      default:
        return concatMap(node.childNodes, function(childName) {
          if (node[childName] == null) {
            return [];
          }
          if (__indexOf.call(node.listMembers, childName) >= 0) {
            return concatMap(node[childName], collectIdentifiers);
          } else {
            return collectIdentifiers(node[childName]);
          }
        });
    }
  })());
};

handleSpecialParam = function(param, original, block) {
  var p;
  switch (false) {
    case !original["instanceof"](CS.Identifier):
      return param;
    case !original["instanceof"](CS.MemberAccessOps):
      p = genSym('param');
      block.body.unshift(stmt(new JS.AssignmentExpression('=', param, p)));
      return p;
    case !original["instanceof"](CS.DefaultParam):
      block.body.unshift(new JS.IfStatement(new JS.BinaryExpression('==', new JS.Literal(null), param.param), stmt(new JS.AssignmentExpression('=', param.param, param["default"]))));
      return handleSpecialParam.call(this, param.param, original.param, block);
    default:
      throw new Error("Unsupported parameter type: " + original.className);
  }
};

needsCaching = function(node) {
  return (envEnrichments(node, [])).length > 0 || (node["instanceof"](CS.FunctionApplications, CS.DoOp, CS.NewOp, CS.ArrayInitialiser, CS.ObjectInitialiser, CS.RegExp, CS.HeregExp)) || (any(difference(node.childNodes, node.listMembers), function(n) {
    return needsCaching(node[n]);
  })) || (any(node.listMembers, function(n) {
    return any(node[n], needsCaching);
  }));
};

forceBlock = function(node) {
  if (node == null) {
    return new JS.BlockStatement([]);
  }
  node = stmt(node);
  if (node["instanceof"](JS.BlockStatement)) {
    return node;
  } else {
    return new JS.BlockStatement([node]);
  }
};

makeVarDeclaration = function(vars) {
  var decls, v;
  vars.sort(function(a, b) {
    a = a.name.toLowerCase();
    b = b.name.toLowerCase();
    if (a < b) {
      return -1;
    } else if (a > b) {
      return 1;
    } else {
      return 0;
    }
  });
  decls = (function() {
    var _i, _len, _results;
    _results = [];
    for (_i = 0, _len = vars.length; _i < _len; _i++) {
      v = vars[_i];
      _results.push(new JS.VariableDeclarator(v));
    }
    return _results;
  })();
  return new JS.VariableDeclaration('var', decls);
};

memberAccess = function(e, member) {
  var _ref3;
  if (__indexOf.call(jsReserved, member) >= 0 || (_ref3 = +member.toString()[0], __indexOf.call([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], _ref3) >= 0)) {
    return new JS.MemberExpression(true, expr(e), new JS.Literal(member));
  } else {
    return new JS.MemberExpression(false, expr(e), new JS.Identifier(member));
  }
};

dynamicMemberAccess = function(e, index) {
  if ((index["instanceof"](JS.Literal)) && typeof index.value === 'string') {
    return memberAccess(e, index.value);
  } else {
    return new JS.MemberExpression(true, e, index);
  }
};

helperNames = {};

helpers = {
  "extends": function() {
    var block, child, ctor, key, parent, protoAccess;
    protoAccess = function(e) {
      return memberAccess(e, 'prototype');
    };
    child = new JS.Identifier('child');
    parent = new JS.Identifier('parent');
    ctor = new JS.Identifier('ctor');
    key = new JS.Identifier('key');
    block = [new JS.ForInStatement(key, parent, new JS.IfStatement(helpers.isOwn(parent, key), stmt(new JS.AssignmentExpression('=', new JS.MemberExpression(true, child, key), new JS.MemberExpression(true, parent, key))))), new JS.FunctionDeclaration(ctor, [], new JS.BlockStatement([stmt(new JS.AssignmentExpression('=', memberAccess(new JS.ThisExpression, 'constructor'), child))])), new JS.AssignmentExpression('=', protoAccess(ctor), protoAccess(parent)), new JS.AssignmentExpression('=', protoAccess(child), new JS.NewExpression(ctor, [])), new JS.AssignmentExpression('=', memberAccess(child, '__super__'), protoAccess(parent)), makeReturn(child)];
    return new JS.FunctionDeclaration(helperNames["extends"], [child, parent], new JS.BlockStatement(map(block, stmt)));
  },
  isOwn: function() {
    var args, functionBody, hop, params;
    hop = memberAccess(new JS.ObjectExpression([]), 'hasOwnProperty');
    params = args = [new JS.Identifier('o'), new JS.Identifier('p')];
    functionBody = [new JS.CallExpression(memberAccess(hop, 'call'), args)];
    return new JS.FunctionDeclaration(helperNames.isOwn, params, makeReturn(new JS.BlockStatement(map(functionBody, stmt))));
  },
  "in": function() {
    var functionBody, i, length, list, loopBody, member, varDeclaration;
    member = new JS.Identifier('member');
    list = new JS.Identifier('list');
    i = genSym('i');
    length = genSym('length');
    varDeclaration = new JS.VariableDeclaration('var', [new JS.VariableDeclarator(i, new JS.Literal(0)), new JS.VariableDeclarator(length, memberAccess(list, 'length'))]);
    loopBody = new JS.IfStatement(new JS.BinaryExpression('&&', new JS.BinaryExpression('in', i, list), new JS.BinaryExpression('===', new JS.MemberExpression(true, list, i), member)), new JS.ReturnStatement(new JS.Literal(true)));
    functionBody = [new JS.ForStatement(varDeclaration, new JS.BinaryExpression('<', i, length), new JS.UpdateExpression('++', true, i), loopBody), new JS.Literal(false)];
    return new JS.FunctionDeclaration(helperNames["in"], [member, list], makeReturn(new JS.BlockStatement(map(functionBody, stmt))));
  }
};

enabledHelpers = [];

for (h in helpers) {
  fn = helpers[h];
  helperNames[h] = genSym(h);
  helpers[h] = (function(h, fn) {
    return function() {
      enabledHelpers.push(fn());
      return (helpers[h] = function() {
        return new JS.CallExpression(helperNames[h], arguments);
      }).apply(this, arguments);
    };
  })(h, fn);
}

inlineHelpers = {
  undef: function() {
    return new JS.UnaryExpression('void', new JS.Literal(0));
  }
};

for (h in inlineHelpers) {
  fn = inlineHelpers[h];
  helpers[h] = fn;
}

exports.Compiler = (function() {
  var defaultRules,
    _this = this;

  Compiler.compile = function() {
    var _ref3;
    return (_ref3 = new Compiler).compile.apply(_ref3, arguments);
  };

  defaultRules = [
    [
      CS.Program, function(_arg) {
        var block, decls, inScope, options, program;
        block = _arg.block, inScope = _arg.inScope, options = _arg.options;
        if (block == null) {
          return new JS.Program([]);
        }
        block = stmt(block);
        block = block["instanceof"](JS.BlockStatement) ? block.body : [block];
        [].push.apply(block, enabledHelpers);
        decls = nub(concatMap(block, declarationsNeededRecursive));
        if (decls.length > 0) {
          if (options.bare) {
            block.unshift(makeVarDeclaration(decls));
          } else {
            block = [stmt(new JS.UnaryExpression('void', new JS.CallExpression(memberAccess(new JS.FunctionExpression(null, [], new JS.BlockStatement(block)), 'call'), [new JS.ThisExpression])))];
          }
        }
        program = new JS.Program(block);
        program.leadingComments = [
          {
            type: 'Line',
            value: ' Generated by CoffeeScript 2.0.0'
          }
        ];
        return program;
      }
    ], [
      CS.Block, function(_arg) {
        var statements;
        statements = _arg.statements;
        switch (statements.length) {
          case 0:
            return new JS.EmptyStatement;
          case 1:
            return new stmt(statements[0]);
          default:
            return new JS.BlockStatement(map(statements, stmt));
        }
      }
    ], [
      CS.SeqOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.SequenceExpression([left, right]);
      }
    ], [
      CS.Conditional, function(_arg) {
        var ancestry, block, condition, elseBlock, _ref3;
        condition = _arg.condition, block = _arg.block, elseBlock = _arg.elseBlock, ancestry = _arg.ancestry;
        if (elseBlock != null) {
          if (block == null) {
            throw new Error('Conditional with non-null elseBlock requires non-null block');
          }
          if (!elseBlock["instanceof"](JS.IfStatement)) {
            elseBlock = forceBlock(elseBlock);
          }
        }
        if ((elseBlock != null) || ((_ref3 = ancestry[0]) != null ? _ref3["instanceof"](CS.Conditional) : void 0)) {
          block = forceBlock(block);
        }
        return new JS.IfStatement(expr(condition), stmt(block), elseBlock);
      }
    ], [
      CS.ForIn, function(_arg) {
        var block, e, expression, filterExpr, i, keyAssignee, length, step, valAssignee, varDeclaration;
        valAssignee = _arg.valAssignee, keyAssignee = _arg.keyAssignee, expression = _arg.expression, step = _arg.step, filterExpr = _arg.filterExpr, block = _arg.block;
        i = genSym('i');
        length = genSym('length');
        block = forceBlock(block);
        e = needsCaching(this.expression) ? genSym('cache') : expression;
        varDeclaration = new JS.VariableDeclaration('var', [new JS.VariableDeclarator(i, new JS.Literal(0)), new JS.VariableDeclarator(length, memberAccess(e, 'length'))]);
        if (e !== expression) {
          varDeclaration.declarations.unshift(new JS.VariableDeclarator(e, expression));
        }
        if (this.filterExpr != null) {
          block.body.unshift(stmt(new JS.IfStatement(new JS.UnaryExpression('!', filterExpr), new JS.ContinueStatement)));
        }
        if (keyAssignee != null) {
          block.body.unshift(stmt(new JS.AssignmentExpression('=', keyAssignee, i)));
        }
        block.body.unshift(stmt(new JS.AssignmentExpression('=', valAssignee, new JS.MemberExpression(true, e, i))));
        return new JS.ForStatement(varDeclaration, new JS.BinaryExpression('<', i, length), new JS.UpdateExpression('++', true, i), block);
      }
    ], [
      CS.ForOf, function(_arg) {
        var block, e, expression, filterExpr, keyAssignee, right, valAssignee;
        keyAssignee = _arg.keyAssignee, valAssignee = _arg.valAssignee, expression = _arg.expression, filterExpr = _arg.filterExpr, block = _arg.block;
        block = forceBlock(block);
        e = this.isOwn && needsCaching(this.expression) ? genSym('cache') : expr(expression);
        if (this.filterExpr != null) {
          block.body.unshift(stmt(new JS.IfStatement(new JS.UnaryExpression('!', filterExpr), new JS.ContinueStatement)));
        }
        if (valAssignee != null) {
          block.body.unshift(stmt(new JS.AssignmentExpression('=', valAssignee, new JS.MemberExpression(true, e, keyAssignee))));
        }
        if (this.isOwn) {
          block.body.unshift(stmt(new JS.IfStatement(new JS.UnaryExpression('!', helpers.isOwn(e, keyAssignee)), new JS.ContinueStatement)));
        }
        right = e === expression ? e : new JS.AssignmentExpression('=', e, expression);
        return new JS.ForInStatement(keyAssignee, right, block);
      }
    ], [
      CS.While, function(_arg) {
        var block, condition;
        condition = _arg.condition, block = _arg.block;
        return new JS.WhileStatement(expr(condition), forceBlock(block));
      }
    ], [
      CS.Switch, function(_arg) {
        var c, cases, elseBlock, expression, _i, _len, _ref3;
        expression = _arg.expression, cases = _arg.cases, elseBlock = _arg.elseBlock;
        cases = concat(cases);
        if (elseBlock != null) {
          cases.push(new JS.SwitchCase(null, [stmt(elseBlock)]));
        }
        _ref3 = cases.slice(0, -1);
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          c = _ref3[_i];
          if (c.consequent.length > 0) {
            c.consequent.push(new JS.BreakStatement);
          }
        }
        return new JS.SwitchStatement(expression, cases);
      }
    ], [
      CS.SwitchCase, function(_arg) {
        var block, cases, conditions;
        conditions = _arg.conditions, block = _arg.block;
        cases = map(conditions, function(c) {
          return new JS.SwitchCase(c, []);
        });
        block = stmt(block);
        block = block["instanceof"](JS.BlockStatement) ? block.body : [block];
        cases[cases.length - 1].consequent = block;
        return cases;
      }
    ], [
      CS.Throw, function(_arg) {
        var expression;
        expression = _arg.expression;
        return new JS.ThrowStatement(expression);
      }
    ], [
      CS.Range, function(_arg) {
        var accum, body, condition, conditionAlternate, conditionConsequent, conditionTest, i, left, left_, range, rawLeft, rawRight, right, right_, update, vars, _i, _j, _results, _results1;
        left_ = _arg.left, right_ = _arg.right;
        if (((this.left["instanceof"](CS.Int)) || ((this.left["instanceof"](CS.UnaryNegateOp)) && this.left.expression["instanceof"](CS.Int))) && ((this.right["instanceof"](CS.Int)) || ((this.right["instanceof"](CS.UnaryNegateOp)) && this.right.expression["instanceof"](CS.Int)))) {
          rawLeft = this.left["instanceof"](CS.UnaryNegateOp) ? -this.left.expression.data : this.left.data;
          rawRight = this.right["instanceof"](CS.UnaryNegateOp) ? -this.right.expression.data : this.right.data;
          if ((Math.abs(rawLeft - rawRight)) <= 20) {
            range = this.isInclusive ? (function() {
              _results = [];
              for (var _i = rawLeft; rawLeft <= rawRight ? _i <= rawRight : _i >= rawRight; rawLeft <= rawRight ? _i++ : _i--){ _results.push(_i); }
              return _results;
            }).apply(this) : (function() {
              _results1 = [];
              for (var _j = rawLeft; rawLeft <= rawRight ? _j < rawRight : _j > rawRight; rawLeft <= rawRight ? _j++ : _j--){ _results1.push(_j); }
              return _results1;
            }).apply(this);
            return new JS.ArrayExpression(map(range, function(n) {
              if (n < 0) {
                return new JS.UnaryExpression('-', new JS.Literal(-n));
              } else {
                return new JS.Literal(n);
              }
            }));
          }
        }
        accum = genSym('accum');
        body = [stmt(new JS.AssignmentExpression('=', accum, new JS.ArrayExpression([])))];
        if (needsCaching(left_)) {
          left = genSym('from');
          body.push(stmt(new JS.AssignmentExpression('=', left, left_)));
        } else {
          left = left_;
        }
        if (needsCaching(right_)) {
          right = genSym('to');
          body.push(stmt(new JS.AssignmentExpression('=', right, right_)));
        } else {
          right = right_;
        }
        i = genSym('i');
        vars = new JS.VariableDeclaration('var', [new JS.VariableDeclarator(i, left)]);
        conditionTest = new JS.BinaryExpression('<=', left, right);
        conditionConsequent = new JS.BinaryExpression((this.isInclusive ? '<=' : '<'), i, right);
        conditionAlternate = new JS.BinaryExpression((this.isInclusive ? '>=' : '>'), i, right);
        condition = new JS.ConditionalExpression(conditionTest, conditionConsequent, conditionAlternate);
        update = new JS.ConditionalExpression(conditionTest, new JS.UpdateExpression('++', true, i), new JS.UpdateExpression('--', true, i));
        body.push(new JS.ForStatement(vars, condition, update, stmt(new JS.CallExpression(memberAccess(accum, 'push'), [i]))));
        body.push(new JS.ReturnStatement(accum));
        return new JS.CallExpression(memberAccess(new JS.FunctionExpression(null, [], new JS.BlockStatement(body)), 'apply'), [new JS.ThisExpression, new JS.Identifier('arguments')]);
      }
    ], [
      CS.ArrayInitialiser, function(_arg) {
        var members;
        members = _arg.members;
        return new JS.ArrayExpression(map(members, expr));
      }
    ], [
      CS.ObjectInitialiser, function(_arg) {
        var members;
        members = _arg.members;
        return new JS.ObjectExpression(members);
      }
    ], [
      CS.ObjectInitialiserMember, function(_arg) {
        var expression, key;
        key = _arg.key, expression = _arg.expression;
        return new JS.Property(key, expr(expression));
      }
    ], [
      CS.DefaultParam, function(_arg) {
        var d, param;
        param = _arg.param, d = _arg["default"];
        return {
          param: param,
          "default": d
        };
      }
    ], [
      CS.Function, CS.BoundFunction, function(_arg) {
        var ancestry, block, last, newThis, pIndex, parameters, parameters_, performedRewrite, rewriteThis, _ref3;
        parameters = _arg.parameters, block = _arg.block, ancestry = _arg.ancestry;
        if (!((_ref3 = ancestry[0]) != null ? _ref3["instanceof"](CS.Constructor) : void 0)) {
          block = makeReturn(block);
        }
        block = forceBlock(block);
        last = block.body.slice(-1)[0];
        if ((last != null ? last["instanceof"](JS.ReturnStatement) : void 0) && !(last.argument != null)) {
          block.body = block.body.slice(0, -1);
        }
        parameters_ = (function() {
          var _i, _ref4, _results;
          if (parameters.length === 0) {
            return [];
          } else {
            _results = [];
            for (pIndex = _i = _ref4 = parameters.length - 1; _ref4 <= 0 ? _i <= 0 : _i >= 0; pIndex = _ref4 <= 0 ? ++_i : --_i) {
              _results.push(handleSpecialParam.call(this, parameters[pIndex], this.parameters[pIndex], block));
            }
            return _results;
          }
        }).call(this);
        parameters = parameters_.reverse();
        performedRewrite = false;
        if (this["instanceof"](CS.BoundFunction)) {
          newThis = genSym('this');
          rewriteThis = generateMutatingWalker(function() {
            if (this["instanceof"](JS.ThisExpression)) {
              performedRewrite = true;
              return newThis;
            } else if (this["instanceof"](JS.FunctionExpression, JS.FunctionDeclaration)) {
              return this;
            } else {
              return rewriteThis(this);
            }
          });
          rewriteThis(block);
        }
        fn = new JS.FunctionExpression(null, parameters, block);
        if (performedRewrite) {
          return new JS.SequenceExpression([new JS.AssignmentExpression('=', newThis, new JS.ThisExpression), fn]);
        } else {
          return fn;
        }
      }
    ], [
      CS.Class, function(_arg) {
        var args, block, c, compile, ctor, ctorIndex, ctorRef, i, iife, instance, member, memberName, name, nameAssignee, params, parent, parentRef, protoAssignOp, protoMember, ps, rewriteThis, _, _i, _j, _len, _len1, _ref3, _ref4, _ref5;
        nameAssignee = _arg.nameAssignee, parent = _arg.parent, name = _arg.name, ctor = _arg.ctor, block = _arg.block, compile = _arg.compile;
        args = [];
        params = [];
        parentRef = genSym('super');
        block = forceBlock(block);
        if ((name["instanceof"](JS.Identifier)) && (_ref3 = name.name, __indexOf.call(jsReserved, _ref3) >= 0)) {
          name = genSym(name.name);
        }
        if (ctor != null) {
          _ref4 = block.body;
          for (i = _i = 0, _len = _ref4.length; _i < _len; i = ++_i) {
            c = _ref4[i];
            if (!(c["instanceof"](JS.FunctionDeclaration))) {
              continue;
            }
            ctorIndex = i;
            break;
          }
          block.body.splice(ctorIndex, 1, ctor);
        } else {
          ctor = new JS.FunctionDeclaration(name, [], new JS.BlockStatement([]));
          ctorIndex = 0;
          block.body.unshift(ctor);
        }
        ctor.id = name;
        if ((this.ctor != null) && !this.ctor.expression["instanceof"](CS.Functions)) {
          ctorRef = genSym('externalCtor');
          ctor.body.body.push(makeReturn(new JS.CallExpression(memberAccess(ctorRef, 'apply'), [new JS.ThisExpression, new JS.Identifier('arguments')])));
          block.body.splice(ctorIndex, 0, stmt(new JS.AssignmentExpression('=', ctorRef, compile(this.ctor.expression))));
        }
        if (this.boundMembers.length > 0) {
          instance = genSym('instance');
          _ref5 = this.boundMembers;
          for (_j = 0, _len1 = _ref5.length; _j < _len1; _j++) {
            protoAssignOp = _ref5[_j];
            memberName = protoAssignOp.assignee.data.toString();
            ps = (function() {
              var _k, _len2, _ref6, _results;
              _ref6 = protoAssignOp.expression.parameters;
              _results = [];
              for (_k = 0, _len2 = _ref6.length; _k < _len2; _k++) {
                _ = _ref6[_k];
                _results.push(genSym());
              }
              return _results;
            })();
            member = memberAccess(new JS.ThisExpression, memberName);
            protoMember = memberAccess(memberAccess(name, 'prototype'), memberName);
            fn = new JS.FunctionExpression(null, ps, new JS.BlockStatement([makeReturn(new JS.CallExpression(memberAccess(protoMember, 'apply'), [instance, new JS.Identifier('arguments')]))]));
            ctor.body.body.unshift(stmt(new JS.AssignmentExpression('=', member, fn)));
          }
          ctor.body.body.unshift(stmt(new JS.AssignmentExpression('=', instance, new JS.ThisExpression)));
        }
        if (parent != null) {
          params.push(parentRef);
          args.push(parent);
          block.body.unshift(stmt(helpers["extends"](name, parentRef)));
        }
        block.body.push(new JS.ReturnStatement(new JS.ThisExpression));
        rewriteThis = generateMutatingWalker(function() {
          if (this["instanceof"](JS.ThisExpression)) {
            return name;
          } else if (this["instanceof"](JS.FunctionExpression, JS.FunctionDeclaration)) {
            return this;
          } else {
            return rewriteThis(this);
          }
        });
        rewriteThis(block);
        iife = new JS.CallExpression(new JS.FunctionExpression(null, params, block), args);
        if (nameAssignee != null) {
          return new JS.AssignmentExpression('=', nameAssignee, iife);
        } else {
          return iife;
        }
      }
    ], [
      CS.Constructor, function(_arg) {
        var expression, tmpName;
        expression = _arg.expression;
        tmpName = genSym('class');
        if (this.expression["instanceof"](CS.Functions)) {
          return new JS.FunctionDeclaration(tmpName, expression.params, forceBlock(expression.body));
        } else {
          return new JS.FunctionDeclaration(tmpName, [], new JS.BlockStatement([]));
        }
      }
    ], [
      CS.ClassProtoAssignOp, function(_arg) {
        var assignee, compile, expression, protoMember;
        assignee = _arg.assignee, expression = _arg.expression, compile = _arg.compile;
        if (this.expression["instanceof"](CS.BoundFunction)) {
          return compile(new CS.ClassProtoAssignOp(this.assignee, new CS.Function(this.expression.parameters, this.expression.block)));
        } else {
          protoMember = memberAccess(memberAccess(new JS.ThisExpression, 'prototype'), this.assignee.data);
          return new JS.AssignmentExpression('=', protoMember, expression);
        }
      }
    ], [
      CS.AssignOp, function(_arg) {
        var ancestry, assignSeq, assignee, assignments, compile, e, expression, i, m, valueUsed, _i, _j, _len, _len1, _ref3, _ref4;
        assignee = _arg.assignee, expression = _arg.expression, ancestry = _arg.ancestry, compile = _arg.compile;
        switch (false) {
          case !this.assignee["instanceof"](CS.ArrayInitialiser):
            assignments = [];
            e = this.expression;
            valueUsed = usedAsExpression(this, ancestry);
            if (this.assignee.members.length > 1 && (needsCaching(e)) || valueUsed) {
              e = new CS.GenSym('cache');
              assignments.push(new CS.AssignOp(e, this.expression));
            }
            _ref3 = this.assignee.members;
            for (i = _i = 0, _len = _ref3.length; _i < _len; i = ++_i) {
              m = _ref3[i];
              assignments.push(new CS.AssignOp(m, new CS.DynamicMemberAccessOp(e, new CS.Int(i))));
            }
            if (!assignments.length) {
              return helpers.undef();
            }
            assignSeq = foldl1(assignments, function(a, b) {
              return new CS.SeqOp(a, b);
            });
            return compile((valueUsed ? new CS.SeqOp(assignSeq, e) : assignSeq));
          case !this.assignee["instanceof"](CS.ObjectInitialiser):
            assignments = [];
            e = this.expression;
            valueUsed = usedAsExpression(this, ancestry);
            if (this.assignee.members.length > 1 && (needsCaching(e)) || valueUsed) {
              e = new CS.GenSym('cache');
              assignments.push(new CS.AssignOp(e, this.expression));
            }
            _ref4 = this.assignee.members;
            for (i = _j = 0, _len1 = _ref4.length; _j < _len1; i = ++_j) {
              m = _ref4[i];
              assignments.push(new CS.AssignOp(m.expression, new CS.MemberAccessOp(e, m.key.data)));
            }
            if (!assignments.length) {
              return helpers.undef();
            }
            assignSeq = foldl1(assignments, function(a, b) {
              return new CS.SeqOp(a, b);
            });
            return compile((valueUsed ? new CS.SeqOp(assignSeq, e) : assignSeq));
          case !this.assignee["instanceof"](CS.Identifier, CS.GenSym, CS.MemberAccessOps):
            return new JS.AssignmentExpression('=', assignee, expr(expression));
          default:
            throw new Error("compile: AssignOp: unassignable assignee: " + this.assignee.className);
        }
      }
    ], [
      CS.CompoundAssignOp, function(_arg) {
        var assignee, expression, op;
        assignee = _arg.assignee, expression = _arg.expression;
        op = (function() {
          switch (this.op) {
            case CS.LogicalAndOp:
              return '&&';
            case CS.LogicalOrOp:
              return '||';
            case CS.BitOrOp:
              return '|';
            case CS.BitXorOp:
              return '^';
            case CS.BitAndOp:
              return '&';
            case CS.LeftShiftOp:
              return '<<';
            case CS.SignedRightShiftOp:
              return '>>';
            case CS.UnsignedRightShiftOp:
              return '>>>';
            case CS.PlusOp:
              return '+';
            case CS.SubtractOp:
              return '-';
            case CS.MultiplyOp:
              return '*';
            case CS.DivideOp:
              return '/';
            case CS.RemOp:
              return '%';
            default:
              throw new Error('Unrecognised compound assignment operator');
          }
        }).call(this);
        if (op === '&&' || op === '||') {
          return new JS.BinaryExpression(op, assignee, new JS.AssignmentExpression('=', assignee, expression));
        } else {
          return new JS.AssignmentExpression("" + op + "=", assignee, expression);
        }
      }
    ], [
      CS.ExistsAssignOp, function(_arg) {
        var assignee, condition, expression, inScope, _ref3;
        assignee = _arg.assignee, expression = _arg.expression, inScope = _arg.inScope;
        if ((assignee["instanceof"](JS.Identifier)) && (_ref3 = assignee.name, __indexOf.call(inScope, _ref3) < 0)) {
          throw new Error("the variable \"" + assignee.name + "\" can't be assigned with ?= because it has not been defined.");
        }
        condition = new JS.BinaryExpression('!=', new JS.Literal(null), assignee);
        return new JS.ConditionalExpression(condition, assignee, new JS.AssignmentExpression('=', assignee, expr(expression)));
      }
    ], [
      CS.FunctionApplication, function(_arg) {
        var args, fn;
        fn = _arg["function"], args = _arg["arguments"];
        return new JS.CallExpression(expr(fn), map(args, expr));
      }
    ], [
      CS.NewOp, function(_arg) {
        var args, ctor;
        ctor = _arg.ctor, args = _arg["arguments"];
        return new JS.NewExpression(ctor, args);
      }
    ], [
      CS.HeregExp, function(_arg) {
        var args, expression, flag, flags;
        expression = _arg.expression;
        args = [expression];
        if (flags = ((function() {
          var _i, _len, _ref3, _results;
          _ref3 = ['g', 'i', 'm', 'y'];
          _results = [];
          for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
            flag = _ref3[_i];
            if (this.flags[flag]) {
              _results.push(flag);
            }
          }
          return _results;
        }).call(this)).join('')) {
          args.push(new JS.Literal(flags));
        }
        return new JS.NewExpression(new JS.Identifier('RegExp'), args);
      }
    ], [
      CS.RegExp, function() {
        var flag, flags, re;
        flags = ((function() {
          var _i, _len, _ref3, _results;
          _ref3 = ['g', 'i', 'm', 'y'];
          _results = [];
          for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
            flag = _ref3[_i];
            if (this.flags[flag]) {
              _results.push(flag);
            }
          }
          return _results;
        }).call(this)).join('');
        re = new RegExp(this.data, flags);
        return new JS.Literal(re);
      }
    ], [
      CS.ConcatOp, function(_arg) {
        var ancestry, left, leftmost, plusOp, right, _ref3;
        left = _arg.left, right = _arg.right, ancestry = _arg.ancestry;
        plusOp = new JS.BinaryExpression('+', left, right);
        if (!ancestry[0]["instanceof"](CS.ConcatOp)) {
          leftmost = plusOp;
          while ((_ref3 = leftmost.left) != null ? _ref3.left : void 0) {
            leftmost = leftmost.left;
          }
          if (!leftmost.left["instanceof"](JS.Literal)) {
            leftmost.left = new JS.BinaryExpression('+', new JS.Literal(''), leftmost.left);
          }
        }
        return plusOp;
      }
    ], [
      CS.MemberAccessOp, function(_arg) {
        var expression;
        expression = _arg.expression;
        return memberAccess(expression, this.memberName);
      }
    ], [
      CS.ProtoMemberAccessOp, function(_arg) {
        var expression;
        expression = _arg.expression;
        return memberAccess(memberAccess(expression, 'prototype'), this.memberName);
      }
    ], [
      CS.DynamicMemberAccessOp, function(_arg) {
        var expression, indexingExpr;
        expression = _arg.expression, indexingExpr = _arg.indexingExpr;
        return dynamicMemberAccess(expression, indexingExpr);
      }
    ], [
      CS.DynamicProtoMemberAccessOp, function(_arg) {
        var expression, indexingExpr;
        expression = _arg.expression, indexingExpr = _arg.indexingExpr;
        return dynamicMemberAccess(memberAccess(expression, 'prototype'), indexingExpr);
      }
    ], [
      CS.SoakedMemberAccessOp, function(_arg) {
        var condition, e, expression, inScope, node, _ref3;
        expression = _arg.expression, inScope = _arg.inScope;
        e = needsCaching(this.expression) ? genSym('cache') : expression;
        condition = new JS.BinaryExpression('!=', new JS.Literal(null), e);
        if ((e["instanceof"](JS.Identifier)) && (_ref3 = e.name, __indexOf.call(inScope, _ref3) < 0)) {
          condition = new JS.BinaryExpression('&&', new JS.BinaryExpression('!==', new JS.Literal('undefined'), new JS.UnaryExpression('typeof', e)), condition);
        }
        node = new JS.ConditionalExpression(condition, memberAccess(e, this.memberName), helpers.undef());
        if (e === expression) {
          return node;
        } else {
          return new JS.SequenceExpression([new JS.AssignmentExpression('=', e, expression), node]);
        }
      }
    ], [
      CS.Slice, function(_arg) {
        var args, expression, left, right;
        expression = _arg.expression, left = _arg.left, right = _arg.right;
        args = left != null ? [left] : right != null ? [new JS.Literal(0)] : [];
        if (right != null) {
          args.push(this.isInclusive ? (right["instanceof"](JS.Literal)) && typeof right.data === 'number' ? new JS.Literal(right.data + 1) : new JS.BinaryExpression('+', new JS.UnaryExpression('+', right), new JS.Literal(1)) : right);
        }
        return new JS.CallExpression(memberAccess(expression, 'slice'), args);
      }
    ], [
      CS.ExistsOp, function(_arg) {
        var condition, e, inScope, left, node, right, _ref3;
        left = _arg.left, right = _arg.right, inScope = _arg.inScope;
        e = needsCaching(this.left) ? genSym('cache') : left;
        condition = new JS.BinaryExpression('!=', new JS.Literal(null), e);
        if ((e["instanceof"](JS.Identifier)) && (_ref3 = e.name, __indexOf.call(inScope, _ref3) < 0)) {
          condition = new JS.BinaryExpression('&&', new JS.BinaryExpression('!==', new JS.Literal('undefined'), new JS.UnaryExpression('typeof', e)), condition);
        }
        node = new JS.ConditionalExpression(condition, e, right);
        if (e === left) {
          return node;
        } else {
          return new JS.SequenceExpression([new JS.AssignmentExpression('=', e, left), node]);
        }
      }
    ], [
      CS.UnaryExistsOp, function(_arg) {
        var expression, inScope, nullTest, typeofTest, _ref3;
        expression = _arg.expression, inScope = _arg.inScope;
        nullTest = new JS.BinaryExpression('!=', new JS.Literal(null), expression);
        if ((expression["instanceof"](JS.Identifier)) && (_ref3 = expression.name, __indexOf.call(inScope, _ref3) < 0)) {
          typeofTest = new JS.BinaryExpression('!==', new JS.Literal('undefined'), new JS.UnaryExpression('typeof', expression));
          return new JS.BinaryExpression('&&', typeofTest, nullTest);
        } else {
          return nullTest;
        }
      }
    ], [
      CS.DoOp, function(_arg) {
        var args, compile, expression, param;
        expression = _arg.expression, compile = _arg.compile;
        args = [];
        if (this.expression["instanceof"](CS.Function)) {
          args = (function() {
            var _i, _len, _ref3, _results;
            _ref3 = this.expression.parameters;
            _results = [];
            for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
              param = _ref3[_i];
              switch (false) {
                case !param["instanceof"](CS.AssignOp):
                  _results.push(param.expression);
                  break;
                case !param["instanceof"](CS.Identifier, CS.MemberAccessOp):
                  _results.push(param);
                  break;
                default:
                  _results.push(helpers.undef());
              }
            }
            return _results;
          }).call(this);
        }
        return compile(new CS.FunctionApplication(this.expression, args));
      }
    ], [
      CS.Return, function(_arg) {
        var e;
        e = _arg.expression;
        return new JS.ReturnStatement(expr(e));
      }
    ], [
      CS.Break, function() {
        return new JS.BreakStatement;
      }
    ], [
      CS.Continue, function() {
        return new JS.ContinueStatement;
      }
    ], [
      CS.DivideOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('/', expr(left), expr(right));
      }
    ], [
      CS.MultiplyOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('*', expr(left), expr(right));
      }
    ], [
      CS.RemOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('%', expr(left), expr(right));
      }
    ], [
      CS.PlusOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('+', expr(left), expr(right));
      }
    ], [
      CS.SubtractOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('-', expr(left), expr(right));
      }
    ], [
      CS.OfOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('in', expr(left), expr(right));
      }
    ], [
      CS.InOp, function(_arg) {
        var comparisons, left, right;
        left = _arg.left, right = _arg.right;
        if (!(needsCaching(left)) && (this.right["instanceof"](CS.ArrayInitialiser)) && this.right.members.length < 5) {
          if (right.elements.length === 0) {
            return new JS.Literal(false);
          } else {
            comparisons = map(right.elements, function(e) {
              return new JS.BinaryExpression('===', left, e);
            });
            return foldl1(comparisons, function(l, r) {
              return new JS.BinaryExpression('||', l, r);
            });
          }
        } else {
          return helpers["in"](expr(left), expr(right));
        }
      }
    ], [
      CS.ExtendsOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return helpers["extends"](expr(left), expr(right));
      }
    ], [
      CS.InstanceofOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('instanceof', expr(left), expr(right));
      }
    ], [
      CS.LogicalAndOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('&&', expr(left), expr(right));
      }
    ], [
      CS.LogicalOrOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('||', expr(left), expr(right));
      }
    ], [
      CS.EQOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('===', expr(left), expr(right));
      }
    ], [
      CS.NEQOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('!==', expr(left), expr(right));
      }
    ], [
      CS.GTEOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('>=', expr(left), expr(right));
      }
    ], [
      CS.GTOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('>', expr(left), expr(right));
      }
    ], [
      CS.LTEOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('<=', expr(left), expr(right));
      }
    ], [
      CS.LTOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('<', expr(left), expr(right));
      }
    ], [
      CS.BitAndOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('&', expr(left), expr(right));
      }
    ], [
      CS.BitOrOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('|', expr(left), expr(right));
      }
    ], [
      CS.BitXorOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('^', expr(left), expr(right));
      }
    ], [
      CS.LeftShiftOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('<<', expr(left), expr(right));
      }
    ], [
      CS.SignedRightShiftOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('>>', expr(left), expr(right));
      }
    ], [
      CS.UnsignedRightShiftOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('>>>', expr(left), expr(right));
      }
    ], [
      CS.PreDecrementOp, function(_arg) {
        var e;
        e = _arg.expression;
        return new JS.UpdateExpression('--', true, expr(e));
      }
    ], [
      CS.PreIncrementOp, function(_arg) {
        var e;
        e = _arg.expression;
        return new JS.UpdateExpression('++', true, expr(e));
      }
    ], [
      CS.PostDecrementOp, function(_arg) {
        var e;
        e = _arg.expression;
        return new JS.UpdateExpression('--', false, expr(e));
      }
    ], [
      CS.PostIncrementOp, function(_arg) {
        var e;
        e = _arg.expression;
        return new JS.UpdateExpression('++', false, expr(e));
      }
    ], [
      CS.UnaryPlusOp, function(_arg) {
        var e;
        e = _arg.expression;
        return new JS.UnaryExpression('+', expr(e));
      }
    ], [
      CS.UnaryNegateOp, function(_arg) {
        var e;
        e = _arg.expression;
        return new JS.UnaryExpression('-', expr(e));
      }
    ], [
      CS.LogicalNotOp, function(_arg) {
        var e;
        e = _arg.expression;
        return new JS.UnaryExpression('!', expr(e));
      }
    ], [
      CS.BitNotOp, function(_arg) {
        var e;
        e = _arg.expression;
        return new JS.UnaryExpression('~', expr(e));
      }
    ], [
      CS.TypeofOp, function(_arg) {
        var e;
        e = _arg.expression;
        return new JS.UnaryExpression('typeof', expr(e));
      }
    ], [
      CS.DeleteOp, function(_arg) {
        var e;
        e = _arg.expression;
        return new JS.UnaryExpression('delete', expr(e));
      }
    ], [
      CS.Identifier, function() {
        return new JS.Identifier(this.data);
      }
    ], [
      CS.GenSym, (function() {
        var memos, symbols;
        symbols = [];
        memos = [];
        return function() {
          var memo;
          if (__indexOf.call(symbols, this) >= 0) {
            return memos[symbols.indexOf(this)];
          } else {
            symbols.push(this);
            memos.push(memo = genSym(this.data));
            return memo;
          }
        };
      })()
    ], [
      CS.Bool, CS.Int, CS.Float, CS.String, function() {
        return new JS.Literal(this.data);
      }
    ], [
      CS.Null, function() {
        return new JS.Literal(null);
      }
    ], [
      CS.Undefined, function() {
        return helpers.undef();
      }
    ], [
      CS.This, function() {
        return new JS.ThisExpression;
      }
    ]
  ];

  function Compiler() {
    var ctor, ctors, handler, _i, _j, _k, _len, _len1, _ref3;
    this.rules = {};
    for (_i = 0, _len = defaultRules.length; _i < _len; _i++) {
      _ref3 = defaultRules[_i], ctors = 2 <= _ref3.length ? __slice.call(_ref3, 0, _j = _ref3.length - 1) : (_j = 0, []), handler = _ref3[_j++];
      for (_k = 0, _len1 = ctors.length; _k < _len1; _k++) {
        ctor = ctors[_k];
        this.addRule(ctor.prototype.className, handler);
      }
    }
  }

  Compiler.prototype.addRule = function(ctor, handler) {
    this.rules[ctor] = handler;
    return this;
  };

  Compiler.prototype.compile = (function() {
    var defaultRule, generateSymbols, walk;
    walk = function(fn, inScope, ancestry, options) {
      var child, childName, children, jsNode, member, _i, _len, _ref3, _ref4;
      if (((_ref3 = ancestry[0]) != null ? _ref3["instanceof"](CS.Function, CS.BoundFunction) : void 0) && this === ancestry[0].block) {
        inScope = union(inScope, concatMap(ancestry[0].parameters, beingDeclared));
      }
      ancestry.unshift(this);
      children = {};
      _ref4 = this.childNodes;
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        childName = _ref4[_i];
        if (this[childName] != null) {
          children[childName] = (function() {
            var _j, _len1, _ref5, _results;
            if (__indexOf.call(this.listMembers, childName) >= 0) {
              _ref5 = this[childName];
              _results = [];
              for (_j = 0, _len1 = _ref5.length; _j < _len1; _j++) {
                member = _ref5[_j];
                jsNode = walk.call(member, fn, inScope, ancestry);
                inScope = union(inScope, envEnrichments(member, inScope));
                _results.push(jsNode);
              }
              return _results;
            } else {
              child = this[childName];
              jsNode = walk.call(child, fn, inScope, ancestry);
              inScope = union(inScope, envEnrichments(child, inScope));
              return jsNode;
            }
          }).call(this);
        }
      }
      children.inScope = inScope;
      children.ancestry = ancestry;
      children.options = options;
      children.compile = function(node) {
        return walk.call(node.g(), fn, inScope, ancestry);
      };
      ancestry.shift();
      return fn.call(this, children);
    };
    generateSymbols = (function() {
      var format, generateName, generatedSymbols;
      generatedSymbols = {};
      format = function(pre, counter) {
        var div, mod, _ref3;
        if (pre) {
          return "" + pre + "$" + (counter || '');
        } else {
          if (counter < 26) {
            return String.fromCharCode(0x61 + counter);
          } else {
            _ref3 = divMod(counter, 26), div = _ref3[0], mod = _ref3[1];
            return (format(pre, div - 1)) + format(pre, mod);
          }
        }
      };
      generateName = function(node, _arg) {
        var formatted, nsCounters, usedSymbols, _ref3;
        usedSymbols = _arg.usedSymbols, nsCounters = _arg.nsCounters;
        if (owns(generatedSymbols, node.uniqueId)) {
          return generatedSymbols[node.uniqueId];
        } else {
          nsCounters[node.ns] = owns(nsCounters, node.ns) ? 1 + nsCounters[node.ns] : 0;
          while (_ref3 = (formatted = format(node.ns, nsCounters[node.ns])), __indexOf.call(usedSymbols, _ref3) >= 0) {
            ++nsCounters[node.ns];
          }
          return generatedSymbols[node.uniqueId] = formatted;
        }
      };
      return generateMutatingWalker(function(state) {
        var declNames, declaredSymbols, decls, k, newNode, nsCounters, params, usedSymbols, v;
        declaredSymbols = state.declaredSymbols, usedSymbols = state.usedSymbols, nsCounters = state.nsCounters;
        state.declaredSymbols = union(declaredSymbols, map(declarationsNeeded(this), function(id) {
          return id.name;
        }));
        newNode = (function() {
          if (this["instanceof"](JS.GenSym)) {
            newNode = new JS.Identifier(generateName(this, state));
            usedSymbols.push(newNode.name);
            return newNode;
          } else if (this["instanceof"](JS.FunctionExpression, JS.FunctionDeclaration)) {
            params = concatMap(this.params, collectIdentifiers);
            state.usedSymbols = nub(__slice.call(usedSymbols).concat(__slice.call(params)));
            state.nsCounters = {};
            for (k in nsCounters) {
              if (!__hasProp.call(nsCounters, k)) continue;
              v = nsCounters[k];
              state.nsCounters[k] = v;
            }
            newNode = generateSymbols(this, state);
            newNode.body = forceBlock(newNode.body);
            declNames = nub(difference(map(concatMap(this.body.body, declarationsNeededRecursive), function(id) {
              return id.name;
            }), union(declaredSymbols, params)));
            decls = map(declNames, function(name) {
              return new JS.Identifier(name);
            });
            if (decls.length > 0) {
              newNode.body.body.unshift(makeVarDeclaration(decls));
            }
            return newNode;
          } else {
            return generateSymbols(this, state);
          }
        }).call(this);
        state.declaredSymbols = union(declaredSymbols, map(declarationsNeededRecursive(newNode), function(id) {
          return id.name;
        }));
        return newNode;
      });
    })();
    defaultRule = function() {
      throw new Error("compile: Non-exhaustive patterns in case: " + this.className);
    };
    return function(ast, options) {
      var jsAST, rules, _ref3;
      if (options == null) {
        options = {};
      }
      if ((_ref3 = options.bare) == null) {
        options.bare = false;
      }
      rules = this.rules;
      jsAST = walk.call(ast, (function() {
        var _ref4;
        return ((_ref4 = rules[this.className]) != null ? _ref4 : defaultRule).apply(this, arguments);
      }), [], [], options);
      return generateSymbols(jsAST, {
        declaredSymbols: [],
        usedSymbols: jsReserved.slice(0),
        nsCounters: {}
      });
    };
  })();

  return Compiler;

}).call(this);

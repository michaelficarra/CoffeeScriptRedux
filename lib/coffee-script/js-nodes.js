// Generated by CoffeeScript 1.3.3
var ArrayExpression, AssignmentExpression, BinaryExpression, BlockStatement, CallExpression, FunctionDeclaration, FunctionExpression, GenSym, Identifier, Literal, MemberExpression, NewExpression, Nodes, ObjectExpression, Program, SequenceExpression, SwitchCase, SwitchStatement, TryStatement, UnaryExpression, UpdateExpression, VariableDeclaration, createNode, ctor, difference, exports, handleLists, handlePrimitives, isStatement, node, nodeData, params, _i, _len, _ref, _ref1,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __slice = [].slice,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

difference = require('./functional-helpers').difference;

exports = (_ref = typeof module !== "undefined" && module !== null ? module.exports : void 0) != null ? _ref : this;

createNode = function(type, props) {
  return (function(_super) {

    __extends(_Class, _super);

    function _Class() {
      var i, prop, _i, _len;
      for (i = _i = 0, _len = props.length; _i < _len; i = ++_i) {
        prop = props[i];
        this[prop] = arguments[i];
      }
    }

    _Class.prototype.type = type;

    _Class.prototype.childNodes = props;

    return _Class;

  })(Nodes);
};

this.Nodes = Nodes = (function() {

  function Nodes() {}

  Nodes.prototype.listMembers = [];

  Nodes.prototype["instanceof"] = function() {
    var ctor, ctors, _i, _len;
    ctors = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    for (_i = 0, _len = ctors.length; _i < _len; _i++) {
      ctor = ctors[_i];
      if (this.type === ctor.prototype.type) {
        return true;
      }
    }
    return false;
  };

  Nodes.prototype.toJSON = function() {
    var child, json, p, _i, _len, _ref1, _ref2;
    json = {
      type: this.type
    };
    if (this.leadingComments != null) {
      json.leadingComments = this.leadingComments;
    }
    _ref1 = this.childNodes;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      child = _ref1[_i];
      if (__indexOf.call(this.listMembers, child) >= 0) {
        json[child] = (function() {
          var _j, _len1, _ref2, _results;
          _ref2 = this[child];
          _results = [];
          for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
            p = _ref2[_j];
            _results.push(p != null ? p.toJSON() : void 0);
          }
          return _results;
        }).call(this);
      } else {
        json[child] = (_ref2 = this[child]) != null ? _ref2.toJSON() : void 0;
      }
    }
    if ((this.line != null) && (this.column != null)) {
      json.loc = {
        start: {
          line: this.line,
          column: this.column
        }
      };
    }
    if (this.offset != null) {
      json.range = [this.offset, this.raw != null ? this.offset + this.raw.length - 1 : void 0];
    }
    if (this.raw != null) {
      json.raw = this.raw;
    }
    return json;
  };

  return Nodes;

})();

nodeData = [['ArrayExpression', false, ['elements']], ['AssignmentExpression', false, ['operator', 'left', 'right']], ['BinaryExpression', false, ['operator', 'left', 'right']], ['BlockStatement', true, ['body']], ['BreakStatement', true, ['label']], ['CallExpression', false, ['callee', 'arguments']], ['CatchClause', true, ['param', 'body']], ['ConditionalExpression', false, ['test', 'consequent', 'alternate']], ['ContinueStatement', true, ['label']], ['DebuggerStatement', true, []], ['DoWhileStatement', true, ['body', 'test']], ['EmptyStatement', true, []], ['ExpressionStatement', true, ['expression']], ['ForInStatement', true, ['left', 'right', 'body']], ['ForStatement', true, ['init', 'test', 'update', 'body']], ['FunctionDeclaration', true, ['id', 'params', 'body']], ['FunctionExpression', false, ['id', 'params', 'body']], ['GenSym', false, ['ns', 'uniqueId']], ['Identifier', false, ['name']], ['IfStatement', true, ['test', 'consequent', 'alternate']], ['LabeledStatement', true, ['label', 'body']], ['Literal', false, ['value']], ['LogicalExpression', false, ['left', 'right']], ['MemberExpression', false, ['computed', 'object', 'property']], ['NewExpression', false, ['callee', 'arguments']], ['ObjectExpression', false, ['properties']], ['Program', true, ['body']], ['Property', true, ['key', 'value']], ['ReturnStatement', true, ['argument']], ['SequenceExpression', false, ['expressions']], ['SwitchCase', true, ['test', 'consequent']], ['SwitchStatement', true, ['discriminant', 'cases']], ['ThisExpression', false, []], ['ThrowStatement', true, ['argument']], ['TryStatement', true, ['block', 'handlers', 'finalizer']], ['UnaryExpression', false, ['operator', 'argument']], ['UpdateExpression', false, ['operator', 'prefix', 'argument']], ['VariableDeclaration', true, ['kind', 'declarations']], ['VariableDeclarator', true, ['id', 'init']], ['WhileStatement', true, ['test', 'body']], ['WithStatement', true, ['object', 'body']]];

for (_i = 0, _len = nodeData.length; _i < _len; _i++) {
  _ref1 = nodeData[_i], node = _ref1[0], isStatement = _ref1[1], params = _ref1[2];
  exports[node] = ctor = createNode(node, params);
  ctor.prototype.isStatement = isStatement;
  ctor.prototype.isExpression = !isStatement;
}

Program = exports.Program, BlockStatement = exports.BlockStatement, Literal = exports.Literal, Identifier = exports.Identifier, FunctionExpression = exports.FunctionExpression, CallExpression = exports.CallExpression, SequenceExpression = exports.SequenceExpression, ArrayExpression = exports.ArrayExpression, BinaryExpression = exports.BinaryExpression, UnaryExpression = exports.UnaryExpression, NewExpression = exports.NewExpression, VariableDeclaration = exports.VariableDeclaration, ObjectExpression = exports.ObjectExpression, MemberExpression = exports.MemberExpression, UpdateExpression = exports.UpdateExpression, AssignmentExpression = exports.AssignmentExpression, GenSym = exports.GenSym, FunctionDeclaration = exports.FunctionDeclaration, VariableDeclaration = exports.VariableDeclaration, SwitchStatement = exports.SwitchStatement, SwitchCase = exports.SwitchCase, TryStatement = exports.TryStatement;

handlePrimitives = function(ctor, primitives) {
  ctor.prototype.childNodes = difference(ctor.prototype.childNodes, primitives);
  return ctor.prototype.toJSON = function() {
    var json, primitive, _j, _len1;
    json = Nodes.prototype.toJSON.call(this);
    for (_j = 0, _len1 = primitives.length; _j < _len1; _j++) {
      primitive = primitives[_j];
      json[primitive] = this[primitive];
    }
    return json;
  };
};

handlePrimitives(AssignmentExpression, ['operator']);

handlePrimitives(BinaryExpression, ['operator']);

handlePrimitives(GenSym, ['ns', 'uniqueId']);

handlePrimitives(Identifier, ['name']);

handlePrimitives(Literal, ['value']);

handlePrimitives(MemberExpression, ['computed']);

handlePrimitives(UnaryExpression, ['operator']);

handlePrimitives(UpdateExpression, ['operator', 'prefix']);

handlePrimitives(VariableDeclaration, ['kind']);

handleLists = function(ctor, listProps) {
  return ctor.prototype.listMembers = listProps;
};

handleLists(ArrayExpression, ['elements']);

handleLists(BlockStatement, ['body']);

handleLists(CallExpression, ['arguments']);

handleLists(FunctionDeclaration, ['params']);

handleLists(FunctionExpression, ['params']);

handleLists(NewExpression, ['arguments']);

handleLists(ObjectExpression, ['properties']);

handleLists(Program, ['body']);

handleLists(SequenceExpression, ['expressions']);

handleLists(SwitchCase, ['consequent']);

handleLists(SwitchStatement, ['cases']);

handleLists(TryStatement, ['handlers']);

handleLists(VariableDeclaration, ['declarations']);

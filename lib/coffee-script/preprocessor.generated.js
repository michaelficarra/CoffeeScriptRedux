// Generated by CoffeeScript 2.0.0
(function () {
  var cache$, EventEmitter, fs, inspect, Preprocessor, StringScanner;
  fs = require('fs');
  cache$ = require('events');
  EventEmitter = cache$.EventEmitter;
  StringScanner = require('cjs-string-scanner');
  inspect = function (o) {
    return require('util').inspect(o, false, 9e9, true);
  };
  this.Preprocessor = Preprocessor = function (super$) {
    var DEDENT, INDENT, processInput, TERM, ws;
    extends$(Preprocessor, super$);
    ws = '\\t\\x0B\\f \\xA0\\u1680\\u180E\\u2000-\\u200A\\u202F\\u205F\\u3000\\uFEFF';
    INDENT = '\uefef';
    DEDENT = '\ueffe';
    TERM = '\uefff';
    Preprocessor.prototype.p = function (s) {
      if (null != s) {
        this.emit('data', s);
      }
      return s;
    };
    Preprocessor.prototype.scan = function (r) {
      return this.p(this.ss.scan(r));
    };
    processInput = function (isEnd) {
      return function (data) {
        var b, delta, level, newLevel, tok;
        if (!isEnd) {
          this.ss.concat(data);
        }
        while (this.ss.rest().length > 0) {
          switch (this.context.peek()) {
          case null:
          case INDENT:
          case '#{':
          case '[':
          case '(':
          case '{':
            if (this.ss.bol() || this.scan(new RegExp('(?:[' + ws + ']*\\n)+', ''))) {
              while (this.ss.scan(new RegExp('(?:[' + ws + ']*(\\#\\#?(?!\\#)[^\\n]*)?\\n)', ''))) {
                this.p('\n');
              }
              if (!isEnd && null != this.ss.check(new RegExp('[' + ws + '\\n]*$', ''))) {
                return void 0;
              }
              if (null != this.base) {
                if (!(null != this.scan(this.base))) {
                  throw new Error('inconsistent base indentation');
                }
              } else {
                b = this.scan(new RegExp('[' + ws + ']*', ''));
                this.base = new RegExp('' + b + '', '');
              }
              if (null != this.indent) {
                level = function (accum$) {
                  var c;
                  for (var i$ = 0, length$ = this.context.length; i$ < length$; ++i$) {
                    c = this.context[i$];
                    if (!(c === INDENT))
                      continue;
                    accum$.push(0);
                  }
                  return accum$;
                }.call(this, []).length;
                if (this.ss.check(new RegExp('(?:' + this.indent + '){' + (level + 1) + '}[^' + ws + '#]', ''))) {
                  this.scan(new RegExp('(?:' + this.indent + '){' + (level + 1) + '}', ''));
                  this.context.observe(INDENT);
                  this.p(INDENT);
                } else {
                  if (level > 0 && this.ss.check(new RegExp('(?:' + this.indent + '){0,' + (level - 1) + '}[^' + ws + ']', ''))) {
                    newLevel = 0;
                    while (this.scan(new RegExp('' + this.indent + '', ''))) {
                      ++newLevel;
                    }
                    delta = level - newLevel;
                    while (delta--) {
                      this.context.observe(DEDENT);
                      this.p('' + DEDENT + TERM);
                    }
                  } else {
                    if (this.ss.check(new RegExp('(?:' + this.indent + '){' + level + '}[^' + ws + ']', ''))) {
                      this.scan(new RegExp('(?:' + this.indent + '){' + level + '}', ''));
                    } else {
                      throw new Error('invalid indentation');
                    }
                  }
                }
              } else {
                if (this.ss.check(new RegExp('[' + ws + ']+[^' + ws + '#]', ''))) {
                  this.indent = this.scan(new RegExp('[' + ws + ']+', ''));
                  this.context.observe(INDENT);
                  this.p(INDENT);
                }
              }
            }
            tok = function () {
              switch (this.context.peek()) {
              case '[':
                this.scan(/[^\n'"\\\/#`[({\]]+/);
                return this.scan(/\]/);
              case '(':
                this.scan(/[^\n'"\\\/#`[({)]+/);
                return this.scan(/\)/);
              case '#{':
              case '{':
                this.scan(/[^\n'"\\\/#`[({}]+/);
                return this.scan(/\}/);
              default: {
                  this.scan(/[^\n'"\\\/#`[({]+/);
                  return null;
                }
              }
            }.call(this);
            if (tok) {
              this.context.observe(tok);
              continue;
            }
            if (tok = this.scan(/"""|'''|\/\/\/|###|["'/`[({\\]/)) {
              this.context.observe(tok);
            } else {
              if (this.ss.scan(new RegExp('[' + ws + ']*\\#', ''))) {
                this.context.observe('#');
              }
            }
            break;
          case '\\':
            if (this.scan(/[\s\S]/)) {
              this.context.observe('end-\\');
            }
            break;
          case '"""':
            this.scan(/(?:[^"#\\]+|""?(?!")|#(?!{)|\\.)+/);
            this.ss.scan(/\\\n/);
            if (tok = this.scan(/#{|"""/)) {
              this.context.observe(tok);
            } else {
              if (tok = this.scan(/#{|"""/)) {
                this.context.observe(tok);
              }
            }
            break;
          case '"':
            this.scan(/(?:[^"#\\]+|#(?!{)|\\.)+/);
            this.ss.scan(/\\\n/);
            if (tok = this.scan(/#{|"/)) {
              this.context.observe(tok);
            }
            break;
          case "'''":
            this.scan(/(?:[^'\\]+|''?(?!')|\\.)+/);
            this.ss.scan(/\\\n/);
            if (tok = this.scan(/'''/)) {
              this.context.observe(tok);
            }
            break;
          case "'":
            this.scan(/(?:[^'\\]+|\\.)+/);
            this.ss.scan(/\\\n/);
            if (tok = this.scan(/'/)) {
              this.context.observe(tok);
            }
            break;
          case '###':
            this.scan(/(?:[^#]+|##?(?!#))+/);
            if (tok = this.scan(/###/)) {
              this.context.observe(tok);
            }
            break;
          case '#':
            this.ss.scan(/[^\n]+/);
            if (tok = this.scan(/\n/)) {
              this.context.observe(tok);
            }
            break;
          case '`':
            this.scan(/[^`]+/);
            if (tok = this.scan(/`/)) {
              this.context.observe(tok);
            }
            break;
          case '///':
            this.scan(/(?:[^[/#\\]+|\/\/?(?!\/)|\\.)+/);
            if (tok = this.scan(/#{|\/\/\/|\\/)) {
              this.context.observe(tok);
            } else {
              if (this.ss.scan(/#/)) {
                this.context.observe('heregexp-#');
              } else {
                if (tok = this.scan(/[\[]/)) {
                  this.context.observe('heregexp-' + tok);
                }
              }
            }
            break;
          case 'heregexp-[':
            this.scan(/(?:[^\]\/\\]+|\/\/?(?!\/))+/);
            if (tok = this.scan(/[\]\\]|#{|\/\/\//)) {
              this.context.observe(tok);
            }
            break;
          case 'heregexp-#':
            this.ss.scan(/(?:[^\n/]+|\/\/?(?!\/))+/);
            if (tok = this.scan(/\n|\/\/\//)) {
              this.context.observe(tok);
            }
            break;
          case '/':
            this.scan(/[^[/\\]+/);
            if (tok = this.scan(/[\/\\]/)) {
              this.context.observe(tok);
            } else {
              if (tok = this.scan(/\[/)) {
                this.context.observe('regexp-' + tok);
              }
            }
            break;
          case 'regexp-[':
            this.scan(/[^\]\\]+/);
            if (tok = this.scan(/[\]\\]/)) {
              this.context.observe(tok);
            }
          }
        }
        if (isEnd) {
          this.scan(new RegExp('[' + ws + '\\n]*$', ''));
          while (this.context.length && INDENT === this.context.peek()) {
            this.context.observe(DEDENT);
            this.p('' + DEDENT + TERM);
          }
          if (this.context.length) {
            throw new Error('Unclosed ' + inspect(this.context.peek()) + ' at EOF');
          }
          this.emit('end');
          return void 0;
        }
        return null;
      };
    };
    Preprocessor.prototype.processData = processInput(false);
    Preprocessor.prototype.processEnd = processInput(true);
    this.processSync = function (input) {
      var output, pre;
      pre = new Preprocessor;
      output = '';
      pre.emit = function (type, data) {
        if (type === 'data') {
          return output += data;
        } else
          return void 0;
      };
      pre.processData(input);
      pre.processEnd();
      return output;
    };
    return this;
  }(function Preprocessor() {
    this.base = this.indent = null;
    this.context = [];
    this.context.peek = function () {
      if (this.length) {
        return this[this.length - 1];
      } else {
        return null;
      }
    };
    this.context.err = function (c) {
      throw new Error('Unexpected ' + inspect(c));
    };
    this.context.observe = function (c) {
      var top;
      top = this.peek();
      switch (c) {
      case '"""':
      case "'''":
      case '"':
      case "'":
      case '###':
      case '`':
      case '///':
      case '/':
        if (top === c) {
          this.pop();
        } else {
          this.push(c);
        }
        break;
      case INDENT:
      case '#':
      case '#{':
      case '[':
      case '(':
      case '{':
      case '\\':
      case 'regexp-[':
      case 'regexp-(':
      case 'regexp-{':
      case 'heregexp-#':
      case 'heregexp-[':
      case 'heregexp-(':
      case 'heregexp-{':
        this.push(c);
        break;
      case DEDENT:
        if (!(top === INDENT)) {
          this.err(c);
        }
        this.pop();
        break;
      case '\n':
        if (!indexOf$(top, [
            '#',
            'heregexp-#'
          ])) {
          this.err(c);
        }
        this.pop();
        break;
      case ']':
        if (!indexOf$(top, [
            '[',
            'regexp-[',
            'heregexp-['
          ])) {
          this.err(c);
        }
        this.pop();
        break;
      case ')':
        if (!indexOf$(top, [
            '(',
            'regexp-(',
            'heregexp-('
          ])) {
          this.err(c);
        }
        this.pop();
        break;
      case '}':
        if (!indexOf$(top, [
            '#{',
            '{',
            'regexp-{',
            'heregexp-{'
          ])) {
          this.err(c);
        }
        this.pop();
        break;
      case 'end-\\':
        if (!(top === '\\')) {
          this.err(c);
        }
        this.pop();
        break;
      default:
        throw new Error('undefined token observed: ' + c);
      }
      return this;
    };
    this.ss = new StringScanner('');
  }, EventEmitter);
  function indexOf$(member, list) {
    for (var i$1 = 0, length$1 = list.length; i$1 < length$1; ++i$1)
      if (i$1 in list && list[i$1] === member)
        return i$1;
    return -1;
  }
  function isOwn$(o, p) {
    return {}.hasOwnProperty.call(o, p);
  }
  function extends$(child, parent) {
    var key;
    for (key in parent)
      if (isOwn$(parent, key))
        child[key] = parent[key];
    function ctor() {
      this.constructor = child;
    }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor;
    child.__super__ = parent.prototype;
    return child;
  }
}.call(this));

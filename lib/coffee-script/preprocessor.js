// Generated by CoffeeScript 2.0.0-dev
var EventEmitter, formatParserError, fs, inspect, Preprocessor, StringScanner;
fs = require('fs');
EventEmitter = require('events').EventEmitter;
formatParserError = require('./helpers').formatParserError;
StringScanner = require('StringScanner');
inspect = function (o) {
  return require('util').inspect(o, false, 9e9, true);
};
this.Preprocessor = Preprocessor = function (super$) {
  var DEDENT, INDENT, processInput, TERM, ws;
  extends$(Preprocessor, super$);
  ws = '\\t\\x0B\\f \\xA0\\u1680\\u180E\\u2000-\\u200A\\u202F\\u205F\\u3000\\uFEFF';
  INDENT = '\uefef';
  DEDENT = '\ueffe';
  TERM = '\uefff';
  function Preprocessor() {
    this.base = this.indent = null;
    this.context = [];
    this.context.peek = function () {
      if (this.length) {
        return this[this.length - 1];
      } else {
        return null;
      }
    };
    this.context.err = function (c) {
      throw new Error('Unexpected ' + inspect(c));
    };
    this.context.observe = function (c) {
      var top;
      top = this.peek();
      switch (c) {
      case '"""':
      case "'''":
      case '"':
      case "'":
      case '###':
      case '`':
      case '///':
      case '/':
        if (top === c) {
          this.pop();
        } else {
          this.push(c);
        }
        break;
      case INDENT:
      case '#':
      case '#{':
      case '[':
      case '(':
      case '{':
      case '\\':
      case 'regexp-[':
      case 'regexp-(':
      case 'regexp-{':
      case 'heregexp-#':
      case 'heregexp-[':
      case 'heregexp-(':
      case 'heregexp-{':
        this.push(c);
        break;
      case DEDENT:
        if (!(top === INDENT))
          this.err(c);
        this.pop();
        break;
      case '\n':
        if (!(top === '#' || top === 'heregexp-#'))
          this.err(c);
        this.pop();
        break;
      case ']':
        if (!(top === '[' || top === 'regexp-[' || top === 'heregexp-['))
          this.err(c);
        this.pop();
        break;
      case ')':
        if (!(top === '(' || top === 'regexp-(' || top === 'heregexp-('))
          this.err(c);
        this.pop();
        break;
      case '}':
        if (!(top === '#{' || top === '{' || top === 'regexp-{' || top === 'heregexp-{'))
          this.err(c);
        this.pop();
        break;
      case 'end-\\':
        if (!(top === '\\'))
          this.err(c);
        this.pop();
        break;
      default:
        throw new Error('undefined token observed: ' + c);
      }
      return this;
    };
    this.ss = new StringScanner('');
  }
  Preprocessor.prototype.p = function (s) {
    if (null != s)
      this.emit('data', s);
    return s;
  };
  Preprocessor.prototype.scan = function (r) {
    return this.p(this.ss.scan(r));
  };
  processInput = function (isEnd) {
    return function (data) {
      var delta, lastChar, level, lines, newLevel, nonIdentifierBefore, pos, spaceBefore, tok;
      if (!isEnd)
        this.ss.concat(data);
      while (!this.ss.eos()) {
        switch (this.context.peek()) {
        case null:
        case INDENT:
        case '#{':
        case '[':
        case '(':
        case '{':
          if (this.ss.bol() || this.scan(new RegExp('(?:[' + ws + ']*\\n)+'))) {
            this.scan(new RegExp('(?:[' + ws + ']*(\\#\\#?(?!\\#)[^\\n]*)?\\n)+'));
            if (!isEnd && null != this.ss.check(new RegExp('[' + ws + '\\n]*$')))
              return;
            if (null != this.base) {
              if (!(null != this.scan(this.base))) {
                throw new Error('inconsistent base indentation');
              }
            } else {
              this.base = new RegExp('' + this.scan(new RegExp('[' + ws + ']*')) + '');
            }
            if (null != this.indent) {
              level = function (accum$) {
                var c;
                for (var i$ = 0, length$ = this.context.length; i$ < length$; ++i$) {
                  c = this.context[i$];
                  if (!(c === INDENT))
                    continue;
                  accum$.push(0);
                }
                return accum$;
              }.call(this, []).length;
              if (this.ss.check(new RegExp('(?:' + this.indent + '){' + (level + 1) + '}[^' + ws + '#]'))) {
                this.scan(new RegExp('(?:' + this.indent + '){' + (level + 1) + '}'));
                this.context.observe(INDENT);
                this.p(INDENT);
              } else if (level > 0 && this.ss.check(new RegExp('(?:' + this.indent + '){0,' + (level - 1) + '}[^' + ws + ']'))) {
                newLevel = 0;
                while (this.scan(new RegExp('' + this.indent + ''))) {
                  ++newLevel;
                }
                delta = level - newLevel;
                while (delta--) {
                  this.context.observe(DEDENT);
                  this.p('' + DEDENT + TERM);
                }
              } else if (this.ss.check(new RegExp('(?:' + this.indent + '){' + level + '}[^' + ws + ']'))) {
                this.scan(new RegExp('(?:' + this.indent + '){' + level + '}'));
              } else {
                lines = this.ss.str.substr(0, this.ss.pos).split(/\n/) || [''];
                throw new Error(formatParserError(this.ss.str, {
                  line: lines.length,
                  column: 1 + lines[lines.length - 1].length,
                  found: 'indentation at level ' + level
                }));
              }
            } else if (this.ss.check(new RegExp('[' + ws + ']+[^' + ws + '#]'))) {
              this.indent = this.scan(new RegExp('[' + ws + ']+'));
              this.context.observe(INDENT);
              this.p(INDENT);
            }
          }
          tok = function () {
            switch (this.context.peek()) {
            case '[':
              this.scan(/[^\n'"\\\/#`[({\]]+/);
              return this.scan(/\]/);
            case '(':
              this.scan(/[^\n'"\\\/#`[({)]+/);
              return this.scan(/\)/);
            case '#{':
            case '{':
              this.scan(/[^\n'"\\\/#`[({}]+/);
              return this.scan(/\}/);
            default: {
                this.scan(/[^\n'"\\\/#`[({]+/);
                return null;
              }
            }
          }.call(this);
          if (tok) {
            this.context.observe(tok);
            continue;
          }
          if (tok = this.scan(/"""|'''|\/\/\/|###|["'`#[({\\]/)) {
            this.context.observe(tok);
          } else if (tok = this.scan(/\//)) {
            pos = this.ss.position();
            if (pos > 1) {
              lastChar = this.ss.string()[pos - 2];
              spaceBefore = new RegExp('[' + ws + ']').test(lastChar);
              nonIdentifierBefore = /[\W_$]/.test(lastChar);
            }
            if (pos === 1 || (spaceBefore ? !this.ss.check(new RegExp('[' + ws + '=]')) : nonIdentifierBefore))
              this.context.observe('/');
          }
          break;
        case '\\':
          if (this.scan(/[\s\S]/))
            this.context.observe('end-\\');
          break;
        case '"""':
          this.scan(/(?:[^"#\\]+|""?(?!")|#(?!{)|\\.)+/);
          this.ss.scan(/\\\n/);
          if (tok = this.scan(/#{|"""/)) {
            this.context.observe(tok);
          } else if (tok = this.scan(/#{|"""/)) {
            this.context.observe(tok);
          }
          break;
        case '"':
          this.scan(/(?:[^"#\\]+|#(?!{)|\\.)+/);
          this.ss.scan(/\\\n/);
          if (tok = this.scan(/#{|"/))
            this.context.observe(tok);
          break;
        case "'''":
          this.scan(/(?:[^'\\]+|''?(?!')|\\.)+/);
          this.ss.scan(/\\\n/);
          if (tok = this.scan(/'''/))
            this.context.observe(tok);
          break;
        case "'":
          this.scan(/(?:[^'\\]+|\\.)+/);
          this.ss.scan(/\\\n/);
          if (tok = this.scan(/'/))
            this.context.observe(tok);
          break;
        case '###':
          this.scan(/(?:[^#]+|##?(?!#))+/);
          if (tok = this.scan(/###/))
            this.context.observe(tok);
          break;
        case '#':
          this.scan(/[^\n]+/);
          if (tok = this.scan(/\n/))
            this.context.observe(tok);
          break;
        case '`':
          this.scan(/[^`]+/);
          if (tok = this.scan(/`/))
            this.context.observe(tok);
          break;
        case '///':
          this.scan(/(?:[^[/#\\]+|\/\/?(?!\/)|\\.)+/);
          if (tok = this.scan(/#{|\/\/\/|\\/)) {
            this.context.observe(tok);
          } else if (this.ss.scan(/#/)) {
            this.context.observe('heregexp-#');
          } else if (tok = this.scan(/[\[]/)) {
            this.context.observe('heregexp-' + tok);
          }
          break;
        case 'heregexp-[':
          this.scan(/(?:[^\]\/\\]+|\/\/?(?!\/))+/);
          if (tok = this.scan(/[\]\\]|#{|\/\/\//))
            this.context.observe(tok);
          break;
        case 'heregexp-#':
          this.ss.scan(/(?:[^\n/]+|\/\/?(?!\/))+/);
          if (tok = this.scan(/\n|\/\/\//))
            this.context.observe(tok);
          break;
        case '/':
          this.scan(/[^[/\\]+/);
          if (tok = this.scan(/[\/\\]/)) {
            this.context.observe(tok);
          } else if (tok = this.scan(/\[/)) {
            this.context.observe('regexp-' + tok);
          }
          break;
        case 'regexp-[':
          this.scan(/[^\]\\]+/);
          if (tok = this.scan(/[\]\\]/))
            this.context.observe(tok);
        }
      }
      if (isEnd) {
        this.scan(new RegExp('[' + ws + '\\n]*$'));
        while (this.context.length && INDENT === this.context.peek()) {
          this.context.observe(DEDENT);
          this.p('' + DEDENT + TERM);
        }
        if (this.context.length)
          throw new Error('Unclosed ' + inspect(this.context.peek()) + ' at EOF');
        this.emit('end');
        return;
      }
    };
  };
  Preprocessor.prototype.processData = processInput(false);
  Preprocessor.prototype.processEnd = processInput(true);
  Preprocessor.processSync = function (input) {
    var output, pre;
    pre = new Preprocessor;
    output = '';
    pre.emit = function (type, data) {
      if (type === 'data')
        return output += data;
    };
    pre.processData(input);
    pre.processEnd();
    return output;
  };
  return Preprocessor;
}(EventEmitter);
function isOwn$(o, p) {
  return {}.hasOwnProperty.call(o, p);
}
function extends$(child, parent) {
  var key;
  for (key in parent)
    if (isOwn$(parent, key))
      child[key] = parent[key];
  function ctor() {
    this.constructor = child;
  }
  ctor.prototype = parent.prototype;
  child.prototype = new ctor;
  child.__super__ = parent.prototype;
  return child;
}

// Generated by CoffeeScript 2.0.0-beta9-dev
var ArrayInitialiser, Block, Bool, cache$, cache$1, Class, CompoundAssignOp, concat, concatMap, Conditional, createNodes, difference, exports, ForOf, FunctionApplications, Functions, GenSym, handleLists, handlePrimitives, HeregExp, Identifier, Identifiers, map, NegatedConditional, NewOp, Nodes, nub, ObjectInitialiser, Primitives, Range, RegExp, RegExps, Slice, StaticMemberAccessOps, Super, Switch, SwitchCase, union, While;
cache$ = require('./functional-helpers');
map = cache$.map;
concat = cache$.concat;
concatMap = cache$.concatMap;
difference = cache$.difference;
nub = cache$.nub;
union = cache$.union;
exports = null != ('undefined' !== typeof module && null != module ? module.exports : void 0) ? 'undefined' !== typeof module && null != module ? module.exports : void 0 : this;
createNodes = function (subclasses, superclasses) {
  var className, specs;
  if (null == superclasses)
    superclasses = [];
  for (className in subclasses) {
    if (!isOwn$(subclasses, className))
      continue;
    specs = subclasses[className];
    (function (className) {
      var externalCtor$, isCategory, klass, params, superclass;
      superclass = null != superclasses[0] ? superclasses[0] : function () {
      };
      isCategory = 'undefined' !== typeof specs && null != specs && specs.length === 2;
      params = 'undefined' !== typeof specs && null != specs ? function () {
        switch (specs.length) {
        case 0:
          return [];
        case 1:
        case 2:
          return specs[0];
        }
      }.call(this) : null;
      if (null != params)
        params;
      else
        params = null != superclass.prototype.childNodes ? superclass.prototype.childNodes : [];
      klass = function (super$) {
        extends$(class$, super$);
        externalCtor$ = isCategory ? function () {
        } : function () {
          var i, param;
          for (var i$ = 0, length$ = params.length; i$ < length$; ++i$) {
            param = params[i$];
            i = i$;
            this[param] = arguments[i];
          }
          if (null != this.initialise) {
            this.initialise.apply(this, arguments);
          }
          return this;
        };
        function class$() {
          return externalCtor$.apply(this, arguments);
        }
        class$.prototype.className = className;
        class$.superclasses = superclasses;
        return class$;
      }(superclass);
      if (null != ('undefined' !== typeof specs && null != specs ? specs[0] : void 0)) {
        klass.prototype.childNodes = specs[0];
      }
      if (isCategory) {
        createNodes(specs[1], [klass].concat([].slice.call(superclasses)));
      }
      return exports[className] = klass;
    }(className));
  }
};
createNodes({
  Nodes: [
    [],
    {
      BinOps: [
        [
          'left',
          'right'
        ],
        {
          AssignOps: [
            [
              'assignee',
              'expression'
            ],
            {
              AssignOp: null,
              ClassProtoAssignOp: null,
              CompoundAssignOp: [[
                  'op',
                  'assignee',
                  'expression'
                ]]
            }
          ],
          BitOps: [
            null,
            {
              BitAndOp: null,
              BitOrOp: null,
              BitXorOp: null,
              LeftShiftOp: null,
              SignedRightShiftOp: null,
              UnsignedRightShiftOp: null
            }
          ],
          ComparisonOps: [
            null,
            {
              EQOp: null,
              GTEOp: null,
              GTOp: null,
              LTEOp: null,
              LTOp: null,
              NEQOp: null
            }
          ],
          ConcatOp: null,
          ExistsOp: null,
          ExtendsOp: null,
          InOp: null,
          InstanceofOp: null,
          LogicalOps: [
            null,
            {
              LogicalAndOp: null,
              LogicalOrOp: null
            }
          ],
          MathsOps: [
            null,
            {
              ExpOp: null,
              DivideOp: null,
              MultiplyOp: null,
              RemOp: null,
              SubtractOp: null
            }
          ],
          OfOp: null,
          PlusOp: null,
          Range: [[
              'isInclusive',
              'left',
              'right'
            ]],
          SeqOp: null
        }
      ],
      Statements: [
        [],
        {
          Break: null,
          Continue: null,
          Debugger: null,
          Return: [['expression']],
          Throw: [['expression']]
        }
      ],
      UnaryOps: [
        ['expression'],
        {
          BitNotOp: null,
          DeleteOp: null,
          DoOp: null,
          LogicalNotOp: null,
          NewOp: [[
              'ctor',
              'arguments'
            ]],
          PreDecrementOp: null,
          PreIncrementOp: null,
          PostDecrementOp: null,
          PostIncrementOp: null,
          TypeofOp: null,
          UnaryExistsOp: null,
          UnaryNegateOp: null,
          UnaryPlusOp: null
        }
      ],
      MemberAccessOps: [
        null,
        {
          StaticMemberAccessOps: [
            [
              'expression',
              'memberName'
            ],
            {
              MemberAccessOp: null,
              ProtoMemberAccessOp: null,
              SoakedMemberAccessOp: null,
              SoakedProtoMemberAccessOp: null
            }
          ],
          DynamicMemberAccessOps: [
            [
              'expression',
              'indexingExpr'
            ],
            {
              DynamicMemberAccessOp: null,
              DynamicProtoMemberAccessOp: null,
              SoakedDynamicMemberAccessOp: null,
              SoakedDynamicProtoMemberAccessOp: null
            }
          ]
        }
      ],
      ChainedComparisonOp: [['expression']],
      FunctionApplications: [
        [
          'function',
          'arguments'
        ],
        {
          FunctionApplication: null,
          SoakedFunctionApplication: null
        }
      ],
      Super: [['arguments']],
      Program: [['body']],
      Block: [['statements']],
      Conditional: [[
          'condition',
          'consequent',
          'alternate'
        ]],
      ForIn: [[
          'valAssignee',
          'keyAssignee',
          'target',
          'step',
          'filter',
          'body'
        ]],
      ForOf: [[
          'isOwn',
          'keyAssignee',
          'valAssignee',
          'target',
          'filter',
          'body'
        ]],
      Switch: [[
          'expression',
          'cases',
          'alternate'
        ]],
      SwitchCase: [[
          'conditions',
          'consequent'
        ]],
      Try: [[
          'body',
          'catchAssignee',
          'catchBody',
          'finallyBody'
        ]],
      While: [[
          'condition',
          'body'
        ]],
      ArrayInitialiser: [['members']],
      ObjectInitialiser: [['members']],
      ObjectInitialiserMember: [[
          'key',
          'expression'
        ]],
      Class: [[
          'nameAssignee',
          'parent',
          'ctor',
          'body',
          'boundMembers'
        ]],
      Constructor: [['expression']],
      Functions: [
        [
          'parameters',
          'body'
        ],
        {
          Function: null,
          BoundFunction: null
        }
      ],
      DefaultParam: [[
          'param',
          'default'
        ]],
      Identifiers: [
        ['data'],
        {
          Identifier: null,
          GenSym: null
        }
      ],
      Null: null,
      Primitives: [
        ['data'],
        {
          Bool: null,
          JavaScript: null,
          Numbers: [
            null,
            {
              Int: null,
              Float: null
            }
          ],
          String: null
        }
      ],
      RegExps: [
        null,
        {
          RegExp: [[
              'data',
              'flags'
            ]],
          HeregExp: [[
              'expression',
              'flags'
            ]]
        }
      ],
      This: null,
      Undefined: null,
      Slice: [[
          'expression',
          'isInclusive',
          'left',
          'right'
        ]],
      Rest: [['expression']],
      Spread: [['expression']]
    }
  ]
});
cache$1 = exports;
Nodes = cache$1.Nodes;
Primitives = cache$1.Primitives;
CompoundAssignOp = cache$1.CompoundAssignOp;
StaticMemberAccessOps = cache$1.StaticMemberAccessOps;
Range = cache$1.Range;
ArrayInitialiser = cache$1.ArrayInitialiser;
ObjectInitialiser = cache$1.ObjectInitialiser;
NegatedConditional = cache$1.NegatedConditional;
Conditional = cache$1.Conditional;
Identifier = cache$1.Identifier;
ForOf = cache$1.ForOf;
Functions = cache$1.Functions;
While = cache$1.While;
Class = cache$1.Class;
Block = cache$1.Block;
NewOp = cache$1.NewOp;
Bool = cache$1.Bool;
FunctionApplications = cache$1.FunctionApplications;
RegExps = cache$1.RegExps;
RegExp = cache$1.RegExp;
HeregExp = cache$1.HeregExp;
Super = cache$1.Super;
Slice = cache$1.Slice;
Switch = cache$1.Switch;
Identifiers = cache$1.Identifiers;
SwitchCase = cache$1.SwitchCase;
GenSym = cache$1.GenSym;
Nodes.fromBasicObject = function (obj) {
  return exports[obj.type].fromBasicObject(obj);
};
Nodes.prototype.listMembers = [];
Nodes.prototype.toBasicObject = function () {
  var child, obj, p;
  obj = { type: this.className };
  if (null != this.line) {
    obj.line = this.line;
  }
  if (null != this.column) {
    obj.column = this.column;
  }
  if (null != this.raw) {
    obj.raw = this.raw;
    if (null != this.offset) {
      obj.range = [
        this.offset,
        this.offset + this.raw.length
      ];
    }
  }
  for (var i$ = 0, length$ = this.childNodes.length; i$ < length$; ++i$) {
    child = this.childNodes[i$];
    if (in$(child, this.listMembers)) {
      obj[child] = function (accum$) {
        for (var i$1 = 0, length$1 = this[child].length; i$1 < length$1; ++i$1) {
          p = this[child][i$1];
          accum$.push(p.toBasicObject());
        }
        return accum$;
      }.call(this, []);
    } else {
      obj[child] = null != this[child] ? this[child].toBasicObject() : void 0;
    }
  }
  return obj;
};
Nodes.prototype.fold = function (memo, fn) {
  var child, p;
  for (var i$ = 0, length$ = this.childNodes.length; i$ < length$; ++i$) {
    child = this.childNodes[i$];
    if (in$(child, this.listMembers)) {
      memo = function (accum$) {
        for (var i$1 = 0, length$1 = this[child].length; i$1 < length$1; ++i$1) {
          p = this[child][i$1];
          accum$.push(p.fold(memo, fn));
        }
        return accum$;
      }.call(this, []);
    } else {
      memo = this[child].fold(memo, fn);
    }
  }
  return fn(memo, this);
};
Nodes.prototype.clone = function () {
  var ctor, k, n, v;
  ctor = function () {
  };
  ctor.prototype = this.constructor.prototype;
  n = new ctor;
  for (k in this) {
    if (!isOwn$(this, k))
      continue;
    v = this[k];
    n[k] = v;
  }
  return n;
};
Nodes.prototype['instanceof'] = function () {
  var ctor, ctors, superclasses;
  ctors = arguments.length > 0 ? [].slice.call(arguments, 0) : [];
  superclasses = map(this.constructor.superclasses, function (c) {
    return c.prototype.className;
  });
  for (var i$ = 0, length$ = ctors.length; i$ < length$; ++i$) {
    ctor = ctors[i$];
    if (!in$(ctor.prototype.className, [this.className].concat([].slice.call(superclasses))))
      continue;
    return true;
  }
  return false;
};
Nodes.prototype.r = function (param$) {
  this.raw = param$;
  return this;
};
Nodes.prototype.p = function (param$, param$1, param$2) {
  this.line = param$;
  this.column = param$1;
  this.offset = param$2;
  return this;
};
Nodes.prototype.generated = false;
Nodes.prototype.g = function () {
  this.generated = true;
  return this;
};
handlePrimitives = function (ctor) {
  var primitives;
  primitives = arguments.length > 1 ? [].slice.call(arguments, 1) : [];
  ctor.prototype.childNodes = difference(ctor.prototype.childNodes, primitives);
  return ctor.prototype.toBasicObject = function () {
    var obj, primitive;
    obj = Nodes.prototype.toBasicObject.call(this);
    for (var i$ = 0, length$ = primitives.length; i$ < length$; ++i$) {
      primitive = primitives[i$];
      obj[primitive] = this[primitive];
    }
    return obj;
  };
};
handlePrimitives(Class, 'boundMembers');
handlePrimitives(CompoundAssignOp, 'op');
handlePrimitives(ForOf, 'isOwn');
handlePrimitives(HeregExp, 'flags');
handlePrimitives(Identifiers, 'data');
handlePrimitives(Primitives, 'data');
handlePrimitives(Range, 'isInclusive');
handlePrimitives(RegExp, 'data', 'flags');
handlePrimitives(Slice, 'isInclusive');
handlePrimitives(StaticMemberAccessOps, 'memberName');
handleLists = function (ctor) {
  var listProps;
  listProps = arguments.length > 1 ? [].slice.call(arguments, 1) : [];
  return ctor.prototype.listMembers = listProps;
};
handleLists(ArrayInitialiser, 'members');
handleLists(Block, 'statements');
handleLists(Functions, 'parameters');
handleLists(FunctionApplications, 'arguments');
handleLists(NewOp, 'arguments');
handleLists(ObjectInitialiser, 'members');
handleLists(Super, 'arguments');
handleLists(Switch, 'cases');
handleLists(SwitchCase, 'conditions');
Block.wrap = function (s) {
  return new Block(null != s ? [s] : []).r(s.raw).p(s.line, s.column);
};
Class.prototype.initialise = function () {
  if (null != this.boundMembers)
    this.boundMembers;
  else
    this.boundMembers = [];
  this.name = new GenSym('class');
  if (null != this.nameAssignee) {
    return this.name = function () {
      switch (false) {
      case !this.nameAssignee['instanceof'](Identifier):
        return new Identifier(this.nameAssignee.data);
      case !this.nameAssignee['instanceof'](StaticMemberAccessOps):
        return new Identifier(this.nameAssignee.memberName);
      default:
        return this.name;
      }
    }.call(this);
  }
};
Class.prototype.childNodes.push('name');
ObjectInitialiser.prototype.keys = function () {
  return map(this.members, function (m) {
    return m.key;
  });
};
ObjectInitialiser.prototype.vals = function () {
  return map(this.members, function (m) {
    return m.expression;
  });
};
RegExps.prototype.initialise = function (_, flags) {
  var flag;
  this.flags = {};
  for (var cache$2 = [
        'g',
        'i',
        'm',
        'y'
      ], i$ = 0, length$ = cache$2.length; i$ < length$; ++i$) {
    flag = cache$2[i$];
    this.flags[flag] = in$(flag, flags);
  }
};
exports.NegatedConditional = function (super$) {
  extends$(NegatedConditional, super$);
  function NegatedConditional() {
    Conditional.apply(this, arguments);
  }
  return NegatedConditional;
}(Conditional);
exports.NegatedWhile = function (super$1) {
  extends$(NegatedWhile, super$1);
  function NegatedWhile() {
    While.apply(this, arguments);
  }
  return NegatedWhile;
}(While);
exports.Loop = function (super$2) {
  extends$(Loop, super$2);
  function Loop(body) {
    While.call(this, new Bool(true).g(), body);
  }
  return Loop;
}(While);
function isOwn$(o, p) {
  return {}.hasOwnProperty.call(o, p);
}
function extends$(child, parent) {
  for (var key in parent)
    if (isOwn$(parent, key))
      child[key] = parent[key];
  function ctor() {
    this.constructor = child;
  }
  ctor.prototype = parent.prototype;
  child.prototype = new ctor;
  child.__super__ = parent.prototype;
  return child;
}
function in$(member, list) {
  for (var i = 0, length = list.length; i < length; ++i)
    if (i in list && list[i] === member)
      return true;
  return false;
}

// Generated by CoffeeScript 0.8.5
var checkNodes, ClassScope, console, CS, FunctionScope, g, initializeGlobalTypes, pj, render, reporter, Scope, walk, walk_arrayInializer, walk_assignOp, walk_binOp, walk_block, walk_bool, walk_class, walk_classProtoAssignOp, walk_conditional, walk_float, walk_for, walk_function, walk_functionApplication, walk_identifier, walk_int, walk_memberAccess, walk_newOp, walk_numbers, walk_objectInitializer, walk_primitives, walk_program, walk_range, walk_return, walk_string, walk_struct, walk_switch, walk_this, walk_vardef;
console = {
  log: function () {
  }
};
pj = function () {
  try {
    return require('prettyjson');
  } catch (e$) {
    return;
  }
}.call(this);
render = function (obj) {
  if (null != pj)
    return pj.render(obj);
};
reporter = require('./reporter');
CS = require('./nodes');
cache$ = require('./types');
initializeGlobalTypes = cache$.initializeGlobalTypes;
Scope = cache$.Scope;
ClassScope = cache$.ClassScope;
FunctionScope = cache$.FunctionScope;
g = 'undefined' !== typeof window && null != window ? window : global;
checkNodes = function (cs_ast) {
  var i, root;
  if (!(null != (null != cs_ast.body ? cs_ast.body.statements : void 0)))
    return;
  if (g._root_) {
    root = g._root_;
  } else {
    g._root_ = root = new Scope;
    root.name = 'root';
    for (var cache$1 = [
          'global',
          'exports',
          'module'
        ], i$ = 0, length$ = cache$1.length; i$ < length$; ++i$) {
      i = cache$1[i$];
      root.addVar(i, 'Any', true);
    }
    initializeGlobalTypes(root);
  }
  walk(cs_ast, root);
  return root;
};
walk_struct = function (node, scope) {
  if (node.name instanceof Object) {
    return scope.addType(node.name._base_, node.expr, node.name._templates_);
  } else {
    return scope.addType(node.name, node.expr);
  }
};
walk_vardef = function (node, scope) {
  var symbol;
  symbol = node.name === 'constructor' ? '_constructor_' : node.name;
  if (scope instanceof ClassScope) {
    return scope.addThis(symbol, node.expr);
  } else {
    return scope.addVar(symbol, node.expr);
  }
};
walk_program = function (node, scope) {
  walk(node.body.statements, scope);
  return node.annotation = { dataType: 'Program' };
};
walk_block = function (node, scope) {
  var last_annotation;
  walk(node.statements, scope);
  last_annotation = null != node.statements[node.statements.length - 1] ? node.statements[node.statements.length - 1].annotation : void 0;
  return node.annotation = last_annotation;
};
walk_return = function (node, scope) {
  walk(node.expression, scope);
  if (null != (null != node.expression && null != node.expression.annotation ? node.expression.annotation.dataType : void 0)) {
    scope.addReturnable(node.expression.annotation.dataType);
    return node.annotation = node.expression.annotation;
  }
};
walk_binOp = function (node, scope) {
  var left_type, right_type;
  walk(node.left, scope);
  walk(node.right, scope);
  left_type = null != node.left && null != node.left.annotation ? node.left.annotation.dataType : void 0;
  right_type = null != node.right && null != node.right.annotation ? node.right.annotation.dataType : void 0;
  if (left_type && right_type) {
    if (left_type === 'String' || right_type === 'String') {
      return node.annotation = { dataType: 'String' };
    } else if (left_type === 'Int' && right_type === 'Int') {
      return node.annotation = { dataType: 'Int' };
    } else if ((left_type === 'Int' || left_type === 'Float') && (right_type === 'Int' || right_type === 'Float')) {
      return node.annotation = { dataType: 'Float' };
    } else if ((left_type === 'Int' || left_type === 'Float' || left_type === 'Number') && (right_type === 'Int' || right_type === 'Float' || right_type === 'Number')) {
      return node.annotation = { dataType: 'Number' };
    } else if (left_type === right_type) {
      return node.annotation = { dataType: left_type };
    }
  } else {
    return node.annotation = { dataType: 'Any' };
  }
};
walk_conditional = function (node, scope) {
  var alternate_annotation, annotation, dataType, possibilities;
  walk(node.condition, scope);
  walk(node.consequent, scope);
  if (null != node.alternate)
    walk(node.alternate, scope);
  alternate_annotation = null != (null != node.alternate ? node.alternate.annotation : void 0) ? null != node.alternate ? node.alternate.annotation : void 0 : { dataType: 'Undefined' };
  possibilities = [];
  for (var cache$1 = [
        null != node.consequent ? node.consequent.annotation : void 0,
        alternate_annotation
      ], i$ = 0, length$ = cache$1.length; i$ < length$; ++i$) {
    annotation = cache$1[i$];
    if (!('undefined' !== typeof annotation && null != annotation))
      continue;
    if (null != (null != annotation.dataType ? annotation.dataType.possibilities : void 0)) {
      for (var i$1 = 0, length$1 = annotation.dataType.possibilities.length; i$1 < length$1; ++i$1) {
        dataType = annotation.dataType.possibilities[i$1];
        possibilities.push(dataType);
      }
    } else if (null != annotation.dataType) {
      possibilities.push(annotation.dataType);
    }
  }
  return node.annotation = { dataType: { possibilities: possibilities } };
};
walk_switch = function (node, scope) {
  var alternate_annotation, c, cond, possibilities;
  walk(node.expression, scope);
  for (var i$ = 0, length$ = node.cases.length; i$ < length$; ++i$) {
    c = node.cases[i$];
    for (var i$1 = 0, length$1 = c.conditions.length; i$1 < length$1; ++i$1) {
      cond = c.conditions[i$1];
      walk(c, scope);
    }
    walk(c.consequent, scope);
  }
  walk(node.consequent, scope);
  if (null != node.alternate)
    walk(node.alternate, scope);
  alternate_annotation = null != (null != node.alternate ? node.alternate.annotation : void 0) ? null != node.alternate ? node.alternate.annotation : void 0 : { dataType: 'Undefined' };
  possibilities = [];
  for (var i$2 = 0, length$2 = node.cases.length; i$2 < length$2; ++i$2) {
    c = node.cases[i$2];
    if (!(null != c.annotation))
      continue;
    possibilities.push(c.consequent.annotation);
  }
  possibilities.push(alternate_annotation.dataType);
  return node.annotation = { dataType: { possibilities: possibilities } };
};
walk_newOp = function (node, scope) {
  var _args_, arg, err, Type;
  for (var i$ = 0, length$ = node['arguments'].length; i$ < length$; ++i$) {
    arg = node['arguments'][i$];
    walk(arg, scope);
  }
  Type = scope.getTypeInScope(node.ctor.data);
  if (Type) {
    _args_ = null != node['arguments'] ? node['arguments'].map(function (arg) {
      return null != arg.annotation ? arg.annotation.dataType : void 0;
    }) : void 0;
    if (err = scope.checkAcceptableObject(Type.dataType._constructor_, {
        _args_: null != _args_ ? _args_ : [],
        _return_: 'Any'
      }))
      return reporter.add_error(node, err);
  }
  return node.annotation = { dataType: null != Type ? Type.dataType : void 0 };
};
walk_for = function (node, scope) {
  var dataType, err, nop;
  walk(node.target, scope);
  if (null != node.valAssignee)
    scope.addVar(node.valAssignee.data, null != (null != node.valAssignee && null != node.valAssignee.annotation ? node.valAssignee.annotation.dataType : void 0) ? null != node.valAssignee && null != node.valAssignee.annotation ? node.valAssignee.annotation.dataType : void 0 : 'Any');
  if (null != node.keyAssignee)
    scope.addVar(node.keyAssignee.data, null != (null != node.keyAssignee && null != node.keyAssignee.annotation ? node.keyAssignee.annotation.dataType : void 0) ? null != node.keyAssignee && null != node.keyAssignee.annotation ? node.keyAssignee.annotation.dataType : void 0 : 'Any');
  if (null != node.valAssignee)
    if (null != (null != node.target.annotation && null != node.target.annotation.dataType ? node.target.annotation.dataType.array : void 0)) {
      if (err = scope.checkAcceptableObject(node.valAssignee.annotation.dataType, node.target.annotation.dataType.array)) {
        return reporter.add_error(node, err);
      }
    } else if ((null != node.target && null != node.target.annotation ? node.target.annotation.dataType : void 0) instanceof Object) {
      if (node.target.annotation.dataType instanceof Object) {
        for (nop in node.target.annotation.dataType) {
          dataType = node.target.annotation.dataType[nop];
          if (err = scope.checkAcceptableObject(node.valAssignee.annotation.dataType, dataType))
            return reporter.add_error(node, err);
        }
      }
    }
  walk(node.body, scope);
  node.annotation = null != node.target ? node.target.annotation : void 0;
  delete scope._vars[null != node.valAssignee ? node.valAssignee.data : void 0];
  return delete scope._vars[null != node.keyAssignee ? node.keyAssignee.data : void 0];
};
walk_classProtoAssignOp = function (node, scope) {
  var left, right, symbol;
  left = node.assignee;
  right = node.expression;
  symbol = left.data;
  walk(left, scope);
  if (right['instanceof'](CS.Function) && scope.getThis(symbol)) {
    walk_function(right, scope, scope.getThis(symbol).dataType);
  } else {
    walk(right, scope);
  }
  symbol = left.data;
  if (null != right.annotation)
    return scope.addThis(symbol, right.annotation.dataType);
};
walk_assignOp = function (node, scope) {
  var err, index, l, l_type, left, member, pre_registered_annotation, r, right, symbol, T;
  pre_registered_annotation = node.assignee.annotation;
  left = node.assignee;
  right = node.expression;
  symbol = left.data;
  walk(left, scope);
  if (('function' === typeof right['instanceof'] ? right['instanceof'](CS.Function) : void 0) && scope.getVarInScope(symbol)) {
    walk_function(right, scope, scope.getVarInScope(symbol).dataType);
  } else if (('function' === typeof right['instanceof'] ? right['instanceof'](CS.Function) : void 0) && pre_registered_annotation) {
    walk_function(right, scope, left.annotation.dataType);
  } else {
    walk(right, scope);
  }
  if (left['instanceof'](CS.ArrayInitialiser)) {
    for (var i$ = 0, length$ = left.members.length; i$ < length$; ++i$) {
      member = left.members[i$];
      index = i$;
      if (!(null != member.data))
        continue;
      l = null != left.annotation && null != left.annotation.dataType && null != left.annotation.dataType.array ? left.annotation.dataType.array[index] : void 0;
      r = null != right.annotation && null != right.annotation.dataType && null != right.annotation.dataType.array ? right.annotation.dataType.array[index] : void 0;
      if (err = scope.checkAcceptableObject(l, r))
        reporter.add_error(node, err);
      if (l) {
        scope.addVar(member.data, l, true);
      } else {
        scope.addVar(member.data, 'Any', false);
      }
    }
  } else if (null != (null != left ? left.members : void 0)) {
    for (var i$1 = 0, length$1 = left.members.length; i$1 < length$1; ++i$1) {
      member = left.members[i$1];
      if (!(null != (null != member.key ? member.key.data : void 0)))
        continue;
      if (scope.getVarInScope(member.key.data)) {
        l_type = scope.getVarInScope(member.key.data).dataType;
        if (err = scope.checkAcceptableObject(l_type, null != right.annotation && null != right.annotation.dataType ? right.annotation.dataType[member.key.data] : void 0))
          reporter.add_error(node, err);
      } else {
        scope.addVar(member.key.data, 'Any', false);
      }
    }
  } else if (left['instanceof'](CS.MemberAccessOp)) {
    if (left.expression['instanceof'](CS.This)) {
      T = scope.getThis(left.memberName);
      if (null != T)
        left.annotation = T;
      if (null != T)
        if (err = scope.checkAcceptableObject(left.annotation.dataType, right.annotation.dataType)) {
          reporter.add_error(node, err);
        }
    } else if (null != (null != left.annotation ? left.annotation.dataType : void 0) && null != (null != right.annotation ? right.annotation.dataType : void 0)) {
      if (left.annotation.dataType !== 'Any') {
        if (err = scope.checkAcceptableObject(left.annotation.dataType, right.annotation.dataType)) {
          return reporter.add_error(node, err);
        }
      }
    }
  } else if (left['instanceof'](CS.Identifier)) {
    if (scope.getVarInScope(symbol) && pre_registered_annotation)
      return reporter.add_error(node, 'double bind: ' + symbol);
    if (null != left.annotation.dataType && null != right.annotation)
      if (err = scope.checkAcceptableObject(left.annotation.dataType, right.annotation.dataType)) {
        return reporter.add_error(node, err);
      }
    if (!pre_registered_annotation && (null != right.annotation ? right.annotation.explicit : void 0)) {
      scope.addVar(symbol, right.annotation.dataType, true);
    } else {
      scope.addVar(symbol, left.annotation.dataType, true);
    }
  } else {
    scope.addVar(symbol, 'Any', false);
  }
  console.log('left');
  console.log(render(left));
  console.log('right');
  return console.log(render(right));
};
walk_primitives = function (node, scope) {
  switch (false) {
  case !node['instanceof'](CS.String):
    return walk_string(node, scope);
  case !node['instanceof'](CS.Bool):
    return walk_bool(node, scope);
  case !node['instanceof'](CS.Int):
    return walk_int(node, scope);
  case !node['instanceof'](CS.Float):
    return walk_float(node, scope);
  case !node['instanceof'](CS.Numbers):
    return walk_numbers(node, scope);
  }
};
walk_string = function (node, scope) {
  return null != node.annotation ? node.annotation : node.annotation = {
    dataType: 'String',
    primitive: true
  };
};
walk_int = function (node, scope) {
  return null != node.annotation ? node.annotation : node.annotation = {
    dataType: 'Int',
    primitive: true
  };
};
walk_float = function (node, scope) {
  return null != node.annotation ? node.annotation : node.annotation = {
    dataType: 'Float',
    primitive: true
  };
};
walk_numbers = function (node, scope) {
  return null != node.annotation ? node.annotation : node.annotation = {
    dataType: 'Number',
    primitive: true
  };
};
walk_bool = function (node, scope) {
  return null != node.annotation ? node.annotation : node.annotation = {
    dataType: 'Boolean',
    primitive: true
  };
};
walk_identifier = function (node, scope) {
  var Var;
  if (scope.getVarInScope(node.data)) {
    Var = scope.getVarInScope(node.data);
    return node.annotation = {
      dataType: null != Var ? Var.dataType : void 0,
      explicit: null != Var ? Var.explicit : void 0
    };
  } else {
    if (null != node.annotation)
      return node.annotation;
    else
      return node.annotation = { dataType: 'Any' };
  }
};
walk_this = function (node, scope) {
  var dataType, key, val;
  dataType = {};
  for (key in scope._this) {
    val = scope._this[key];
    dataType[key] = val.dataType;
  }
  return null != node.annotation ? node.annotation : node.annotation = { dataType: dataType };
};
walk_memberAccess = function (node, scope) {
  var dataType;
  if (node['instanceof'](CS.SoakedMemberAccessOp)) {
    walk(node.expression, scope);
    dataType = scope.extendTypeLiteral(null != node.expression.annotation ? node.expression.annotation.dataType : void 0);
    if (null != dataType) {
      return node.annotation = {
        dataType: {
          possibilities: [
            'Undefined',
            dataType[node.memberName]
          ]
        }
      };
    } else {
      return node.annotation = {
        dataType: 'Any',
        explicit: false
      };
    }
  } else if (node['instanceof'](CS.MemberAccessOp)) {
    walk(node.expression, scope);
    dataType = scope.extendTypeLiteral(null != node.expression.annotation ? node.expression.annotation.dataType : void 0);
    if (null != dataType) {
      return node.annotation = {
        dataType: dataType[node.memberName],
        explicit: true
      };
    } else {
      return node.annotation = {
        dataType: 'Any',
        explicit: false
      };
    }
  }
};
walk_arrayInializer = function (node, scope) {
  walk(node.members, scope);
  return null != node.annotation ? node.annotation : node.annotation = {
    dataType: {
      array: null != node.members ? node.members.map(function (m) {
        return null != m.annotation ? m.annotation.dataType : void 0;
      }) : void 0
    }
  };
};
walk_range = function (node, scope) {
  return node.annotation = { dataType: { array: 'Number' } };
};
walk_objectInitializer = function (node, scope) {
  var cache$1, expression, key, nextScope, obj;
  obj = {};
  nextScope = new Scope(scope);
  nextScope.name = 'object';
  for (var i$ = 0, length$ = node.members.length; i$ < length$; ++i$) {
    {
      cache$1 = node.members[i$];
      expression = cache$1.expression;
      key = cache$1.key;
    }
    if (!('undefined' !== typeof key && null != key))
      continue;
    walk(expression, nextScope);
    obj[key.data] = null != expression.annotation ? expression.annotation.dataType : void 0;
  }
  return null != node.annotation ? node.annotation : node.annotation = { dataType: obj };
};
walk_class = function (node, scope) {
  var classScope, cls, constructorScope, fname, index, key, name, param, parent, predef, statement, this_scope, val;
  classScope = new ClassScope(scope);
  this_scope = {};
  if (null != node.nameAssignee ? node.nameAssignee.data : void 0) {
    if (null != node.parent ? node.parent.data : void 0) {
      parent = scope.getTypeInScope(node.parent.data);
      if (parent)
        for (key in parent.dataType) {
          val = parent.dataType[key];
          this_scope[key] = val;
        }
    }
    if (null != (null != node.impl ? node.impl.length : void 0))
      for (var i$ = 0, length$ = node.impl.length; i$ < length$; ++i$) {
        name = node.impl[i$];
        cls = scope.getTypeInScope(name);
        if (cls)
          for (key in cls.dataType) {
            val = cls.dataType[key];
            this_scope[key] = val;
          }
      }
  }
  if (null != (null != node.body ? node.body.statements : void 0))
    for (var i$1 = 0, length$1 = node.body.statements.length; i$1 < length$1; ++i$1) {
      statement = node.body.statements[i$1];
      if (!(statement.dataType === 'vardef'))
        continue;
      walk_vardef(statement, classScope);
    }
  if (null != node.ctor) {
    constructorScope = new FunctionScope(classScope);
    constructorScope._this = classScope._this;
    if (null != node.ctor.expression.parameters)
      if (constructorScope.getThis('_constructor_')) {
        predef = constructorScope.getThis('_constructor_').dataType;
        for (var i$2 = 0, length$2 = node.ctor.expression.parameters.length; i$2 < length$2; ++i$2) {
          param = node.ctor.expression.parameters[i$2];
          index = i$2;
          if (!('undefined' !== typeof param && null != param))
            continue;
          walk(param, constructorScope);
          constructorScope.addVar(param.data, null != (null != predef._args_ ? predef._args_[index] : void 0) ? null != predef._args_ ? predef._args_[index] : void 0 : 'Any');
        }
      } else {
        for (var i$3 = 0, length$3 = node.ctor.expression.parameters.length; i$3 < length$3; ++i$3) {
          param = node.ctor.expression.parameters[i$3];
          index = i$3;
          if (!(null != param))
            continue;
          walk(param, constructorScope);
          constructorScope.addVar(param.data, null != (null != param && null != param.annotation ? param.annotation.dataType : void 0) ? null != param && null != param.annotation ? param.annotation.dataType : void 0 : 'Any');
        }
      }
    if (null != (null != node.ctor.expression.body ? node.ctor.expression.body.statements : void 0))
      for (var i$4 = 0, length$4 = node.ctor.expression.body.statements.length; i$4 < length$4; ++i$4) {
        statement = node.ctor.expression.body.statements[i$4];
        walk(statement, constructorScope);
      }
  }
  if (null != (null != node.body ? node.body.statements : void 0))
    for (var i$5 = 0, length$5 = node.body.statements.length; i$5 < length$5; ++i$5) {
      statement = node.body.statements[i$5];
      if (!(statement.dataType !== 'vardef'))
        continue;
      walk(statement, classScope);
    }
  if (null != node.nameAssignee ? node.nameAssignee.data : void 0) {
    for (fname in classScope._this) {
      val = classScope._this[fname];
      this_scope[fname] = val.dataType;
    }
    return scope.addType(node.nameAssignee.data, this_scope);
  }
};
walk_function = function (node, scope, predef) {
  var _args_, err, functionScope, index, last_expr, member, param, t;
  if (null == predef)
    predef = null;
  _args_ = null != node.parameters ? node.parameters.map(function (param) {
    return null != (null != param.annotation ? param.annotation.dataType : void 0) ? null != param.annotation ? param.annotation.dataType : void 0 : 'Any';
  }) : void 0;
  node.annotation.dataType._args_ = _args_;
  functionScope = new Scope(scope);
  functionScope._name_ = 'function';
  if (scope instanceof ClassScope)
    functionScope._this = scope._this;
  if (null != node.parameters)
    if (predef) {
      node.annotation.dataType = predef;
      for (var i$ = 0, length$ = node.parameters.length; i$ < length$; ++i$) {
        param = node.parameters[i$];
        index = i$;
        if (param.members) {
          for (var i$1 = 0, length$1 = param.members.length; i$1 < length$1; ++i$1) {
            member = param.members[i$1];
            if ((null != member.expression && null != member.expression.expression ? member.expression.expression.raw : void 0) === '@' || (null != member.expression && null != member.expression.expression ? member.expression.expression.raw : void 0) === 'this') {
              t = functionScope.getThis(member.key.data);
              if (!(null != (null != t ? t.dataType : void 0)))
                functionScope.addThis(member.key.data, 'Any');
            } else if (null != member.key ? member.key.data : void 0) {
              functionScope.addVar(member.key.data, 'Any');
            }
          }
        } else if ((null != param.expression ? param.expression.raw : void 0) === '@' || (null != param.expression ? param.expression.raw : void 0) === 'this') {
          t = functionScope.getThis(param.memberName);
          if (err = scope.checkAcceptableObject(null != predef._args_ ? predef._args_[index] : void 0, null != t ? t.dataType : void 0))
            reporter.add_error(node, err);
          if (!(null != (null != t ? t.dataType : void 0)))
            functionScope.addThis(param.memberName, 'Any');
        } else {
          functionScope.addVar(param.data, null != (null != predef._args_ ? predef._args_[index] : void 0) ? null != predef._args_ ? predef._args_[index] : void 0 : 'Any');
        }
      }
    } else {
      for (var i$2 = 0, length$2 = node.parameters.length; i$2 < length$2; ++i$2) {
        param = node.parameters[i$2];
        index = i$2;
        if (param.members) {
          for (var i$3 = 0, length$3 = param.members.length; i$3 < length$3; ++i$3) {
            member = param.members[i$3];
            if ((null != member.expression && null != member.expression.expression ? member.expression.expression.raw : void 0) === '@' || (null != member.expression && null != member.expression.expression ? member.expression.expression.raw : void 0) === 'this') {
              t = functionScope.getThis(member.key.data);
              if (!(null != (null != t ? t.dataType : void 0)))
                functionScope.addThis(member.key.data, 'Any');
            } else if (null != member.key ? member.key.data : void 0) {
              functionScope.addVar(member.key.data, 'Any');
            }
          }
        } else if ((null != param.expression ? param.expression.raw : void 0) === '@' || (null != param.expression ? param.expression.raw : void 0) === 'this') {
          t = functionScope.getThis(param.memberName);
          if (!(null != (null != t ? t.dataType : void 0)))
            functionScope.addThis(param.memberName, 'Any');
        } else {
          functionScope.addVar(param.data, null != (null != param && null != param.annotation ? param.annotation.dataType : void 0) ? null != param && null != param.annotation ? param.annotation.dataType : void 0 : 'Any');
        }
      }
    }
  walk(node.body, functionScope);
  if ((null != node.annotation && null != node.annotation.dataType ? node.annotation.dataType._return_ : void 0) !== 'Any') {
    last_expr = (null != node.body && null != node.body.statements ? node.body.statements.length : void 0) ? null != node.body.statements ? node.body.statements[(null != node.body && null != node.body.statements ? node.body.statements.length : void 0) - 1] : void 0 : node.body;
    if (err = scope.checkAcceptableObject(null != node.annotation ? node.annotation.dataType._return_ : void 0, null != last_expr && null != last_expr.annotation ? last_expr.annotation.dataType : void 0))
      return reporter.add_error(node, err);
  } else {
    last_expr = (null != node.body && null != node.body.statements ? node.body.statements.length : void 0) ? null != node.body.statements ? node.body.statements[(null != node.body && null != node.body.statements ? node.body.statements.length : void 0) - 1] : void 0 : node.body;
    if (null != node.annotation)
      return node.annotation.dataType._return_ = null != last_expr && null != last_expr.annotation ? last_expr.annotation.dataType : void 0;
  }
};
walk_functionApplication = function (node, scope) {
  var _args_, arg, err;
  for (var i$ = 0, length$ = node['arguments'].length; i$ < length$; ++i$) {
    arg = node['arguments'][i$];
    walk(arg, scope);
  }
  walk(node['function'], scope);
  node.annotation = { dataType: null != node['function'].annotation && null != node['function'].annotation.dataType ? node['function'].annotation.dataType._return_ : void 0 };
  if (node['function'].annotation) {
    _args_ = null != node['arguments'] ? node['arguments'].map(function (arg) {
      return null != arg.annotation ? arg.annotation.dataType : void 0;
    }) : void 0;
    if (err = scope.checkAcceptableObject(node['function'].annotation.dataType, {
        _args_: null != _args_ ? _args_ : [],
        _return_: 'Any'
      }))
      return reporter.add_error(node, err);
  }
};
walk = function (node, scope) {
  var s;
  console.log('~~~~~~~~~~~~~~~~~~~~~~~~~~~~');
  console.log('---', null != node ? node.className : void 0, '---', null != node ? node.raw : void 0);
  switch (false) {
  case !!(null != node):
    return;
  case !(null != node.length):
    return function (accum$) {
      for (var i$ = 0, length$ = node.length; i$ < length$; ++i$) {
        s = node[i$];
        accum$.push(walk(s, scope));
      }
      return accum$;
    }.call(this, []);
  case !(node.dataType === 'struct'):
    return walk_struct(node, scope);
  case !(node.dataType === 'vardef'):
    return walk_vardef(node, scope);
  case !node['instanceof'](CS.Program):
    return walk_program(node, scope);
  case !node['instanceof'](CS.Block):
    return walk_block(node, scope);
  case !node['instanceof'](CS.Return):
    return walk_return(node, scope);
  case !node['instanceof'](CS.NewOp):
    return walk_newOp(node, scope);
  case !(node['instanceof'](CS.PlusOp) || node['instanceof'](CS.MultiplyOp) || node['instanceof'](CS.DivideOp) || node['instanceof'](CS.SubtractOp)):
    return walk_binOp(node, scope);
  case !node['instanceof'](CS.Switch):
    return walk_switch(node, scope);
  case !node['instanceof'](CS.Conditional):
    return walk_conditional(node, scope);
  case !(node['instanceof'](CS.ForIn) || node['instanceof'](CS.ForOf)):
    return walk_for(node, scope);
  case !node['instanceof'](CS.Primitives):
    return walk_primitives(node, scope);
  case !node['instanceof'](CS.This):
    return walk_this(node, scope);
  case !node['instanceof'](CS.Identifier):
    return walk_identifier(node, scope);
  case !node['instanceof'](CS.ClassProtoAssignOp):
    return walk_classProtoAssignOp(node, scope);
  case !node['instanceof'](CS.MemberAccessOps):
    return walk_memberAccess(node, scope);
  case !node['instanceof'](CS.ArrayInitialiser):
    return walk_arrayInializer(node, scope);
  case !node['instanceof'](CS.Range):
    return walk_range(node, scope);
  case !node['instanceof'](CS.ObjectInitialiser):
    return walk_objectInitializer(node, scope);
  case !node['instanceof'](CS.Class):
    return walk_class(node, scope);
  case !node['instanceof'](CS.Function):
    return walk_function(node, scope);
  case !node['instanceof'](CS.FunctionApplication):
    return walk_functionApplication(node, scope);
  case !node['instanceof'](CS.AssignOp):
    return walk_assignOp(node, scope);
  }
};
module.exports = { checkNodes: checkNodes };
